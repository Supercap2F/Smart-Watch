Disassembly Listing for SmartWatch
Generated From:
C:/Users/OPTIPLEX  960/Documents/Electronics/Projects/Smart Watch/SmartWatch.X/dist/default/production/SmartWatch.X.production.elf
Aug 8, 2016 11:55:06 AM

---  c:/users/optiplex  960/documents/electronics/projects/smart watch/smartwatch.x/main.c  -------------
1:                   /******************************************************************************/
2:                   /* File:   main.c                                                             */
3:                   /* Author: Supercap2F                                                         */
4:                   /*                                                                            */
5:                   /* Created on August 03, 2016, 11:32 PM                                       */
6:                   /******************************************************************************/
7:                   /* ****************************************************************************/
8:                   /* Section: Included Files                                                    */
9:                   /* ****************************************************************************/
10:                  #define _SUPPRESS_PLIB_WARNING // get rid of annoying warnings 
11:                  #include <plib.h>
12:                  #include "init_sys.h"
13:                  #include "Drivers/LCD/SSD1351.h"
14:                  
15:                  /* ****************************************************************************/
16:                  /* Section: Definitions                                                       */
17:                  /* ****************************************************************************/
18:                  #define FALSE 0
19:                  #define TRUE !FALSE
20:                  #define FCY 100000000
21:                  
22:                  /* ****************************************************************************/
23:                  /* Section: Configuration                                                     */
24:                  /* ****************************************************************************/
25:                  #pragma config FNOSC    = PRIPLL   // the defualt oscillator is Posc with PLL
26:                  #pragma config POSCMOD  = HS       // Posc is in HS mode *MAY NEED TO CHANGE TO XT*
27:                  #pragma config FPLLIDIV = DIV_5    // divide the crystal freq. by 5 going into the PLL
28:                  #pragma config FPLLMUL  = MUL_19   // multiply it by 20 comming out
29:                  #pragma config FPLLODIV = DIV_1    // divide the output from the PLL by one - Posc will be 100MHz
30:                  
31:                  #pragma config ICESEL   = ICS_PGx1 // program on PGEC/PGED 1
32:                  #pragma config OSCIOFNC = OFF      // oscillator out pin disabled 
33:                  
34:                  /* ****************************************************************************/
35:                  /* Section: Local Functions                                                   */
36:                  /* ****************************************************************************/
37:                  
38:                  
39:                  /* ****************************************************************************/
40:                  /* Section: Main Code                                                         */
41:                  /* ****************************************************************************/
42:                  int main() {
9D001694  27BDFFA0   ADDIU SP, SP, -96
9D001698  AFBF005C   SW RA, 92(SP)
9D00169C  AFBE0058   SW S8, 88(SP)
9D0016A0  03A0F021   ADDU S8, SP, ZERO
9D0016A4  3C0205F5   LUI V0, 1525
9D0016A8  3442E100   ORI V0, V0, -7936
9D0016AC  AFC20010   SW V0, 16(S8)
9D0016B0  8FC20010   LW V0, 16(S8)
9D0016B4  AFC20014   SW V0, 20(S8)
9D0016B8  8FC20014   LW V0, 20(S8)
9D0016BC  AFC20018   SW V0, 24(S8)
43:                      SYSTEMConfigPerformance(FCY); // setup system to improve performance 
44:                      init_io_ports();              // initialize I/O ports 
9D001910  0F4007AA   JAL init_io_ports
9D001914  00000000   NOP
45:                      LCD_Setup();                  // setup the LCD
9D001918  0F400692   JAL LCD_Setup
9D00191C  00000000   NOP
46:                      
47:                      while(1){ // main loop 
48:                          LATDbits.LATD8=1;
9D001920  3C03BF88   LUI V1, -16504
9D001924  94626330   LHU V0, 25392(V1)
9D001928  24040001   ADDIU A0, ZERO, 1
9D00192C  7C824204   INS V0, A0, 8, 1
9D001930  A4626330   SH V0, 25392(V1)
49:                          LATDbits.LATD8=0;
9D001934  3C03BF88   LUI V1, -16504
9D001938  94626330   LHU V0, 25392(V1)
9D00193C  7C024204   INS V0, ZERO, 8, 1
9D001940  A4626330   SH V0, 25392(V1)
50:                      }
9D001944  0B400648   J 0x9D001920
9D001948  00000000   NOP
51:                  }
52:                  
---  c:/users/optiplex  960/documents/electronics/projects/smart watch/smartwatch.x/init_sys.c  ---------
1:                   /******************************************************************************/
2:                   /* File:   init_sys.c                                                         */
3:                   /* Author: Supercap2F                                                         */
4:                   /*                                                                            */
5:                   /* Created on August 04, 2016, 5:36 PM                                        */
6:                   /******************************************************************************/
7:                   #define _SUPPRESS_PLIB_WARNING // get rid of annoying warnings 
8:                   #include <plib.h>
9:                   
10:                  /******************************************************************************/
11:                  /* Section: init_io_ports                                                     */
12:                  /******************************************************************************/
13:                  void init_io_ports(void) {
9D001EA8  27BDFFF8   ADDIU SP, SP, -8
9D001EAC  AFBE0004   SW S8, 4(SP)
9D001EB0  03A0F021   ADDU S8, SP, ZERO
14:                      /*******************************************************************/
15:                      /* Section: I/O pin configuration                                  */
16:                      /*******************************************************************/
17:                      /*
18:                       * I/O connections:                            
19:                       ***********************************************************************
20:                       *                              PORTB  
21:                       * RB15 -> Dis_D/C | RB14 -> FTDI_RST | RB13 <- N/C      | RB12 <- N/C
22:                       * RB11 <- CBUS2   | RB10 <- CBUS4    | RB9  <- N/C      | RB8  <- N/C
23:                       * RB7  -> Motor   | RB6  <-a BatIn   | RB5  <- N/C      | RB4  <- N/C
24:                       * RB3  <- N/C     | RB2  <- N/C      | RB1  <- PGC      | RB0  <- PGD
25:                       */
26:                      ANSELB = 0b0011001101111100;
9D001EB4  3C02BF88   LUI V0, -16504
9D001EB8  2403337C   ADDIU V1, ZERO, 13180
9D001EBC  AC436100   SW V1, 24832(V0)
27:                      TRISB  = 0b0011111101111111;
9D001EC0  3C02BF88   LUI V0, -16504
9D001EC4  24033F7F   ADDIU V1, ZERO, 16255
9D001EC8  AC436110   SW V1, 24848(V0)
28:                      LATB   = 0b0000000000000000; 
9D001ECC  3C02BF88   LUI V0, -16504
9D001ED0  AC406130   SW ZERO, 24880(V0)
29:                      
30:                      /***********************************************************************
31:                       *                              PORTC 
32:                       * RC15 <- OSC2    | RC14 <- SOSC0    | RC13 <- SOSC1    | RC12 <- OSC1
33:                       */
34:                      ANSELC = 0b1111000000000000;
9D001ED4  3C02BF88   LUI V0, -16504
9D001ED8  3403F000   ORI V1, ZERO, -4096
9D001EDC  AC436200   SW V1, 25088(V0)
35:                      TRISC  = 0b1111000000000000;
9D001EE0  3C02BF88   LUI V0, -16504
9D001EE4  3403F000   ORI V1, ZERO, -4096
9D001EE8  AC436210   SW V1, 25104(V0)
36:                      LATC   = 0b0000000000000000;
9D001EEC  3C02BF88   LUI V0, -16504
9D001EF0  AC406230   SW ZERO, 25136(V0)
37:                      
38:                      /**********************************************************************
39:                       *                              PORTD 
40:                       * RD11 <- N/C     | RD10 -> Dis_CS   | RD9  -> Dis_RES  | RD8  -> RTCC
41:                       * RD7  <- N/C     | RD6  <- N/C      | RD5  <- Dis_R/W  | RD4  -> Dis_E
42:                       * RD3  <- N/C     | RD2  <- N/C      | RD1  <- N/C      | RD0  <- N/C
43:                       */
44:                      ANSELD = 0b0000100011001111;
9D001EF4  3C02BF88   LUI V0, -16504
9D001EF8  240308CF   ADDIU V1, ZERO, 2255
9D001EFC  AC436300   SW V1, 25344(V0)
45:                      TRISD  = 0b0000100011101111;
9D001F00  3C02BF88   LUI V0, -16504
9D001F04  240308EF   ADDIU V1, ZERO, 2287
9D001F08  AC436310   SW V1, 25360(V0)
46:                      LATD   = 0b0000000000000000;
9D001F0C  3C02BF88   LUI V0, -16504
9D001F10  AC406330   SW ZERO, 25392(V0)
47:                      
48:                      /*********************************************************************** 
49:                       *                              PORTE 
50:                       * RE7:0 -> Dis_D7:0
51:                       */
52:                      ANSELE = 0b0000000000000000;
9D001F14  3C02BF88   LUI V0, -16504
9D001F18  AC406400   SW ZERO, 25600(V0)
53:                      TRISE  = 0b0000000000000000;
9D001F1C  3C02BF88   LUI V0, -16504
9D001F20  AC406410   SW ZERO, 25616(V0)
54:                      LATE   = 0b0000000000000000;
9D001F24  3C02BF88   LUI V0, -16504
9D001F28  AC406430   SW ZERO, 25648(V0)
55:                      
56:                      /***********************************************************************
57:                       *                              PORTF
58:                       * RF6 <- ACC_INT1 | RF5 <- ACC_INT2  | RF4 -> ACC_RST   | RF3 -> Bst_En
59:                       * RF2 <- REG_nPG  | RF1 <- REG_STAT1 | RF0 <- REG_STAT2 
60:                       */
61:                      ANSELF = 0b0000000000000000;
9D001F2C  3C02BF88   LUI V0, -16504
9D001F30  AC406500   SW ZERO, 25856(V0)
62:                      TRISF  = 0b0000000001100111;
9D001F34  3C02BF88   LUI V0, -16504
9D001F38  24030067   ADDIU V1, ZERO, 103
9D001F3C  AC436510   SW V1, 25872(V0)
63:                      LATF   = 0b0000000000000000;
9D001F40  3C02BF88   LUI V0, -16504
9D001F44  AC406530   SW ZERO, 25904(V0)
64:                      
65:                      /***********************************************************************
66:                       *                              PORTG
67:                       * RG9 <- SW1      | RG8 <- SW2       | RG7 <- SW3       | RG6 <- SW4
68:                       * RG3 <- SDA      | RG2 <- SCL
69:                       */ 
70:                      ANSELG = 0b0000000000000000;
9D001F48  3C02BF88   LUI V0, -16504
9D001F4C  AC406600   SW ZERO, 26112(V0)
71:                      TRISG  = 0b0000001111001100;
9D001F50  3C02BF88   LUI V0, -16504
9D001F54  240303CC   ADDIU V1, ZERO, 972
9D001F58  AC436610   SW V1, 26128(V0)
72:                      LATG   = 0b0000000000000000;
9D001F5C  3C02BF88   LUI V0, -16504
9D001F60  AC406630   SW ZERO, 26160(V0)
73:                  };
9D001F64  03C0E821   ADDU SP, S8, ZERO
9D001F68  8FBE0004   LW S8, 4(SP)
9D001F6C  27BD0008   ADDIU SP, SP, 8
9D001F70  03E00008   JR RA
9D001F74  00000000   NOP
---  c:/users/optiplex  960/documents/electronics/projects/smart watch/smartwatch.x/drivers/lcd/ssd1351.c
1:                   /******************************************************************************/
2:                   /* File:   SSD1351.c                                                          */
3:                   /* Author: Supercap2F                                                         */
4:                   /*                                                                            */
5:                   /* Created on August 04, 2016, 6:00 PM                                        */
6:                   /******************************************************************************/
7:                   /******************************************************************************/
8:                   /* Section: Includes                                                          */
9:                   /******************************************************************************/
10:                  #define _SUPPRESS_PLIB_WARNING
11:                  #include <plib.h>
12:                  #include "SSD1351.h"
13:                  
14:                  /******************************************************************************/
15:                  /* Section: LCD_Write Function                                                */
16:                  /******************************************************************************/
17:                  void LCD_Write(unsigned int cmd, unsigned int DorC) {
9D00194C  27BDFFF0   ADDIU SP, SP, -16
9D001950  AFBE000C   SW S8, 12(SP)
9D001954  03A0F021   ADDU S8, SP, ZERO
9D001958  AFC40010   SW A0, 16(S8)
9D00195C  AFC50014   SW A1, 20(S8)
18:                      int x;
19:                      dis_E_RD=1;   // setup the latch 
9D001960  3C03BF88   LUI V1, -16504
9D001964  94626330   LHU V0, 25392(V1)
9D001968  24040001   ADDIU A0, ZERO, 1
9D00196C  7C822104   INS V0, A0, 4, 1
9D001970  A4626330   SH V0, 25392(V1)
20:                      dis_CS=0;     // make sure the chip is selected
9D001974  3C03BF88   LUI V1, -16504
9D001978  94626330   LHU V0, 25392(V1)
9D00197C  7C025284   INS V0, ZERO, 10, 1
9D001980  A4626330   SH V0, 25392(V1)
21:                      dis_R_W=0;    // make this a write operation
9D001984  3C03BF88   LUI V1, -16504
9D001988  94626330   LHU V0, 25392(V1)
9D00198C  7C022944   INS V0, ZERO, 5, 1
9D001990  A4626330   SH V0, 25392(V1)
22:                      dis_D_C=DorC; // is it a data or command 
9D001994  8FC20014   LW V0, 20(S8)
9D001998  304200FF   ANDI V0, V0, 255
9D00199C  30420001   ANDI V0, V0, 1
9D0019A0  304400FF   ANDI A0, V0, 255
9D0019A4  3C03BF88   LUI V1, -16504
9D0019A8  94626130   LHU V0, 24880(V1)
9D0019AC  7C827BC4   INS V0, A0, 15, 1
9D0019B0  A4626130   SH V0, 24880(V1)
23:                      for(x=0;x<300;x++);
9D0019B4  AFC00000   SW ZERO, 0(S8)
9D0019B8  0B400673   J 0x9D0019CC
9D0019BC  00000000   NOP
9D0019C0  8FC20000   LW V0, 0(S8)
9D0019C4  24420001   ADDIU V0, V0, 1
9D0019C8  AFC20000   SW V0, 0(S8)
9D0019CC  8FC20000   LW V0, 0(S8)
9D0019D0  2842012C   SLTI V0, V0, 300
9D0019D4  1440FFFA   BNE V0, ZERO, 0x9D0019C0
9D0019D8  00000000   NOP
24:                      
25:                      LATE=cmd;
9D0019DC  3C02BF88   LUI V0, -16504
9D0019E0  8FC30010   LW V1, 16(S8)
9D0019E4  AC436430   SW V1, 25648(V0)
26:                      
27:                      for(x=0;x<300;x++);
9D0019E8  AFC00000   SW ZERO, 0(S8)
9D0019EC  0B400680   J 0x9D001A00
9D0019F0  00000000   NOP
9D0019F4  8FC20000   LW V0, 0(S8)
9D0019F8  24420001   ADDIU V0, V0, 1
9D0019FC  AFC20000   SW V0, 0(S8)
9D001A00  8FC20000   LW V0, 0(S8)
9D001A04  2842012C   SLTI V0, V0, 300
9D001A08  1440FFFA   BNE V0, ZERO, 0x9D0019F4
9D001A0C  00000000   NOP
28:                      
29:                      dis_CS=1;
9D001A10  3C03BF88   LUI V1, -16504
9D001A14  94626330   LHU V0, 25392(V1)
9D001A18  24040001   ADDIU A0, ZERO, 1
9D001A1C  7C825284   INS V0, A0, 10, 1
9D001A20  A4626330   SH V0, 25392(V1)
30:                      dis_E_RD=0;      // clock the data in 
9D001A24  3C03BF88   LUI V1, -16504
9D001A28  94626330   LHU V0, 25392(V1)
9D001A2C  7C022104   INS V0, ZERO, 4, 1
9D001A30  A4626330   SH V0, 25392(V1)
31:                      
32:                      //for(x=0;x<300;x++);
33:                      
34:                      //dis_E_RD=1; 
35:                  }
9D001A34  03C0E821   ADDU SP, S8, ZERO
9D001A38  8FBE000C   LW S8, 12(SP)
9D001A3C  27BD0010   ADDIU SP, SP, 16
9D001A40  03E00008   JR RA
9D001A44  00000000   NOP
36:                  
37:                  /******************************************************************************/
38:                  /* Section: LCD_Setup Function                                                */
39:                  /******************************************************************************/
40:                  void LCD_Setup(void) {
9D001A48  27BDFFE0   ADDIU SP, SP, -32
9D001A4C  AFBF001C   SW RA, 28(SP)
9D001A50  AFBE0018   SW S8, 24(SP)
9D001A54  03A0F021   ADDU S8, SP, ZERO
41:                      long x;
42:                      for(x=0;x<100000;x++); // delay for 1ms for vdd to become stable
9D001A58  AFC00010   SW ZERO, 16(S8)
9D001A5C  0B40069C   J 0x9D001A70
9D001A60  00000000   NOP
9D001A64  8FC20010   LW V0, 16(S8)
9D001A68  24420001   ADDIU V0, V0, 1
9D001A6C  AFC20010   SW V0, 16(S8)
9D001A70  8FC30010   LW V1, 16(S8)
9D001A74  3C020001   LUI V0, 1
9D001A78  344286A0   ORI V0, V0, -31072
9D001A7C  0062102A   SLT V0, V1, V0
9D001A80  1440FFF8   BNE V0, ZERO, 0x9D001A64
9D001A84  00000000   NOP
43:                      dis_RES=1; // reset display
9D001A88  3C03BF88   LUI V1, -16504
9D001A8C  94626330   LHU V0, 25392(V1)
9D001A90  24040001   ADDIU A0, ZERO, 1
9D001A94  7C824A44   INS V0, A0, 9, 1
9D001A98  A4626330   SH V0, 25392(V1)
44:                      for(x=0;x<10000;x++);
9D001A9C  AFC00010   SW ZERO, 16(S8)
9D001AA0  0B4006AD   J 0x9D001AB4
9D001AA4  00000000   NOP
9D001AA8  8FC20010   LW V0, 16(S8)
9D001AAC  24420001   ADDIU V0, V0, 1
9D001AB0  AFC20010   SW V0, 16(S8)
9D001AB4  8FC20010   LW V0, 16(S8)
9D001AB8  28422710   SLTI V0, V0, 10000
9D001ABC  1440FFFA   BNE V0, ZERO, 0x9D001AA8
9D001AC0  00000000   NOP
45:                      dis_RES=0; // finish reset
9D001AC4  3C03BF88   LUI V1, -16504
9D001AC8  94626330   LHU V0, 25392(V1)
9D001ACC  7C024A44   INS V0, ZERO, 9, 1
9D001AD0  A4626330   SH V0, 25392(V1)
46:                      for(x=0;x<10000;x++);
9D001AD4  AFC00010   SW ZERO, 16(S8)
9D001AD8  0B4006BB   J 0x9D001AEC
9D001ADC  00000000   NOP
9D001AE0  8FC20010   LW V0, 16(S8)
9D001AE4  24420001   ADDIU V0, V0, 1
9D001AE8  AFC20010   SW V0, 16(S8)
9D001AEC  8FC20010   LW V0, 16(S8)
9D001AF0  28422710   SLTI V0, V0, 10000
9D001AF4  1440FFFA   BNE V0, ZERO, 0x9D001AE0
9D001AF8  00000000   NOP
47:                      dis_RES=1;
9D001AFC  3C03BF88   LUI V1, -16504
9D001B00  94626330   LHU V0, 25392(V1)
9D001B04  24040001   ADDIU A0, ZERO, 1
9D001B08  7C824A44   INS V0, A0, 9, 1
9D001B0C  A4626330   SH V0, 25392(V1)
48:                      dis_EN=1;  // turn on VCC
9D001B10  3C03BF88   LUI V1, -16504
9D001B14  90626530   LBU V0, 25904(V1)
9D001B18  24040001   ADDIU A0, ZERO, 1
9D001B1C  7C8218C4   INS V0, A0, 3, 1
9D001B20  A0626530   SB V0, 25904(V1)
49:                      
50:                      
51:                      LCD_Write(SET_SLEEP_OFF,CMD); // send display on command 
9D001B24  240400AF   ADDIU A0, ZERO, 175
9D001B28  00002821   ADDU A1, ZERO, ZERO
9D001B2C  0F400653   JAL LCD_Write
9D001B30  00000000   NOP
52:                      
53:                      //LCD_Write(SET_COLOR_DEPTH,CMD); // set the display color depth to 16bits
54:                      LCD_Write(SET_DIS_ON,CMD); 
9D001B34  240400A5   ADDIU A0, ZERO, 165
9D001B38  00002821   ADDU A1, ZERO, ZERO
9D001B3C  0F400653   JAL LCD_Write
9D001B40  00000000   NOP
55:                      
56:                      
57:                      LCD_Write(WRITE_RAM_CMD,CMD);
9D001B44  2404005C   ADDIU A0, ZERO, 92
9D001B48  00002821   ADDU A1, ZERO, ZERO
9D001B4C  0F400653   JAL LCD_Write
9D001B50  00000000   NOP
58:                      for(x=0;x<9;x++){
9D001B54  AFC00010   SW ZERO, 16(S8)
9D001B58  0B4006E7   J 0x9D001B9C
9D001B5C  00000000   NOP
9D001B90  8FC20010   LW V0, 16(S8)
9D001B94  24420001   ADDIU V0, V0, 1
9D001B98  AFC20010   SW V0, 16(S8)
9D001B9C  8FC20010   LW V0, 16(S8)
9D001BA0  28420009   SLTI V0, V0, 9
9D001BA4  1440FFEE   BNE V0, ZERO, 0x9D001B60
9D001BA8  00000000   NOP
59:                          LCD_Write(0xFF,DAT);
9D001B60  240400FF   ADDIU A0, ZERO, 255
9D001B64  24050001   ADDIU A1, ZERO, 1
9D001B68  0F400653   JAL LCD_Write
9D001B6C  00000000   NOP
60:                          LCD_Write(0x00,DAT);
9D001B70  00002021   ADDU A0, ZERO, ZERO
9D001B74  24050001   ADDIU A1, ZERO, 1
9D001B78  0F400653   JAL LCD_Write
9D001B7C  00000000   NOP
61:                          LCD_Write(0x00,DAT);
9D001B80  00002021   ADDU A0, ZERO, ZERO
9D001B84  24050001   ADDIU A1, ZERO, 1
9D001B88  0F400653   JAL LCD_Write
9D001B8C  00000000   NOP
62:                      }
63:                      
64:                  }
9D001BAC  03C0E821   ADDU SP, S8, ZERO
9D001BB0  8FBF001C   LW RA, 28(SP)
9D001BB4  8FBE0018   LW S8, 24(SP)
9D001BB8  27BD0020   ADDIU SP, SP, 32
9D001BBC  03E00008   JR RA
9D001BC0  00000000   NOP
65:                  
66:                  int  PlotPoint(int x, int y, int state) {}
9D001BC4  27BDFFF8   ADDIU SP, SP, -8
9D001BC8  AFBE0004   SW S8, 4(SP)
9D001BCC  03A0F021   ADDU S8, SP, ZERO
9D001BD0  AFC40008   SW A0, 8(S8)
9D001BD4  AFC5000C   SW A1, 12(S8)
9D001BD8  AFC60010   SW A2, 16(S8)
9D001BDC  03C0E821   ADDU SP, S8, ZERO
9D001BE0  8FBE0004   LW S8, 4(SP)
9D001BE4  27BD0008   ADDIU SP, SP, 8
9D001BE8  03E00008   JR RA
9D001BEC  00000000   NOP
---  c:/users/optiplex  960/documents/electronics/projects/smart watch/smartwatch.x/drivers/lcd/gdgl.c  -
1:                   /***********************************************************************************
2:                    * Graphical Display Graphics Library                                              *
3:                    *                                                                                 *
4:                    * Copyright (c) 2016, Supercap2F                                                  *
5:                    * All rights reserved.                                                            *
6:                    *                                                                                 *
7:                    * Redistribution and use in source and binary forms, with or without              *     
8:                    * modification, are permitted provided that the following conditions are met:     *
9:                    *                                                                                 *
10:                   *    * Redistributions of source code must retain the above copyright notice,     *
11:                   *      this list of conditions and the following disclaimer.                      *
12:                   *                                                                                 *
13:                   *    * Redistributions in binary form must reproduce the above copyright notice,  *
14:                   *      this list of conditions and the following disclaimer in the documentation  *
15:                   *      and/or other materials provided with the distribution.                     *
16:                   *                                                                                 *
17:                   *    * Neither the name of 16Bit-PIC-GDGL nor the names of its                    *
18:                   *      contributors may be used to endorse or promote products derived from       *
19:                   *      this software without specific prior written permission.                   *          
20:                   *                                                                                 *
21:                   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"     *
22:                   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       *
23:                   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  *
24:                   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE    *
25:                   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL      *
26:                   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR      *
27:                   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER      *
28:                   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   *
29:                   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   *
30:                   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.            *
31:                   *                                                                                 *
32:                   * Project repo here:                                                              *
33:                   *      https://github.com/Supercap2F/16Bit-PIC-GDGL                               *
34:                   ***********************************************************************************/
35:                  /************************************************
36:                   * Included Files                               *
37:                   ************************************************/
38:                  #define _SUPPRESS_PLIB_WARNING // get rid of annoying warnings
39:                  #include <plib.h>
40:                  #include "GDGL.h"
41:                  #include "SSD1351.h" // header file for display driver
42:                  #include "Fonts\DefaultFont.h"   // the default font file
43:                  
44:                  /************************************************
45:                   * Global Variables                             *
46:                   ************************************************/
47:                  int tsize=1;   // text size variable
48:                  char txwrap=1; // text wrap variable: 1=wrap 0=don't wrap
49:                  
50:                  /************************************************
51:                   * PlotLine Function - This bit of code is      *
52:                   * based on Bresenham's Line Algorithm but      *
53:                   * was written by "jorticus" and paraphrased by *
54:                   * me. His project here:                        *
55:                   *https://github.com/jorticus/zeitgeber-firmware*                    
56:                   ************************************************/
57:                  void PlotLine(int x0, int y0, int x1, int y1, int color) {
9D000000  27BDFFD0   ADDIU SP, SP, -48
9D000004  AFBF002C   SW RA, 44(SP)
9D000008  AFBE0028   SW S8, 40(SP)
9D00000C  03A0F021   ADDU S8, SP, ZERO
9D000010  AFC40030   SW A0, 48(S8)
9D000014  AFC50034   SW A1, 52(S8)
9D000018  AFC60038   SW A2, 56(S8)
9D00001C  AFC7003C   SW A3, 60(S8)
58:                  	int err2; // second error variable, always twice err 
59:                  
60:                      int deltaX = GDGL_abs(x1 - x0);   // delta x 
9D000020  8FC30038   LW V1, 56(S8)
9D000024  8FC20030   LW V0, 48(S8)
9D000028  00621023   SUBU V0, V1, V0
9D00002C  00402021   ADDU A0, V0, ZERO
9D000030  0F400594   JAL GDGL_abs
9D000034  00000000   NOP
9D000038  AFC20014   SW V0, 20(S8)
61:                      int deltaY = GDGL_abs(y1 - y0);   // delta y
9D00003C  8FC3003C   LW V1, 60(S8)
9D000040  8FC20034   LW V0, 52(S8)
9D000044  00621023   SUBU V0, V1, V0
9D000048  00402021   ADDU A0, V0, ZERO
9D00004C  0F400594   JAL GDGL_abs
9D000050  00000000   NOP
9D000054  AFC20018   SW V0, 24(S8)
62:                  
63:                      int sx = (x0 < x1) ? 1 : -1; // x direction
9D000058  8FC30030   LW V1, 48(S8)
9D00005C  8FC20038   LW V0, 56(S8)
9D000060  0062102A   SLT V0, V1, V0
9D000064  10400004   BEQ V0, ZERO, 0x9D000078
9D000068  00000000   NOP
9D00006C  24020001   ADDIU V0, ZERO, 1
9D000070  0B40001F   J 0x9D00007C
9D000074  00000000   NOP
9D000078  2402FFFF   ADDIU V0, ZERO, -1
9D00007C  AFC2001C   SW V0, 28(S8)
64:                      int sy = (y0 < y1) ? 1 : -1; // y direction 
9D000080  8FC30034   LW V1, 52(S8)
9D000084  8FC2003C   LW V0, 60(S8)
9D000088  0062102A   SLT V0, V1, V0
9D00008C  10400004   BEQ V0, ZERO, 0x9D0000A0
9D000090  00000000   NOP
9D000094  24020001   ADDIU V0, ZERO, 1
9D000098  0B400029   J 0x9D0000A4
9D00009C  00000000   NOP
9D0000A0  2402FFFF   ADDIU V0, ZERO, -1
9D0000A4  AFC20020   SW V0, 32(S8)
65:                      int err = deltaX - deltaY;   // error variable 
9D0000A8  8FC30014   LW V1, 20(S8)
9D0000AC  8FC20018   LW V0, 24(S8)
9D0000B0  00621023   SUBU V0, V1, V0
9D0000B4  AFC20010   SW V0, 16(S8)
66:                  
67:                      while (1) {
68:                          PlotPoint(x0, y0, color); // Plot the current point on the line
9D0000B8  8FC40030   LW A0, 48(S8)
9D0000BC  8FC50034   LW A1, 52(S8)
9D0000C0  8FC60040   LW A2, 64(S8)
9D0000C4  0F4006F1   JAL PlotPoint
9D0000C8  00000000   NOP
69:                  
70:                          if((x0==x1)&&(y0==y1))    // if finished drawing line 
9D0000CC  8FC30030   LW V1, 48(S8)
9D0000D0  8FC20038   LW V0, 56(S8)
9D0000D4  14620007   BNE V1, V0, 0x9D0000F4
9D0000D8  00000000   NOP
9D0000DC  8FC30034   LW V1, 52(S8)
9D0000E0  8FC2003C   LW V0, 60(S8)
9D0000E4  14620003   BNE V1, V0, 0x9D0000F4
9D0000E8  00000000   NOP
71:                              return;               //    return 
9D0000EC  0B40005F   J 0x9D00017C
9D0000F0  00000000   NOP
72:                          err2=2*err;               //
9D0000F4  8FC20010   LW V0, 16(S8)
9D0000F8  00021040   SLL V0, V0, 1
9D0000FC  AFC20024   SW V0, 36(S8)
73:                          if (err2 > -deltaY) {     // check if the error is great enough to increment x0 (for more vertical octants)
9D000100  8FC20018   LW V0, 24(S8)
9D000104  00021823   SUBU V1, ZERO, V0
9D000108  8FC20024   LW V0, 36(S8)
9D00010C  0062102A   SLT V0, V1, V0
9D000110  10400009   BEQ V0, ZERO, 0x9D000138
9D000114  00000000   NOP
74:                              err -= deltaY;        //
9D000118  8FC30010   LW V1, 16(S8)
9D00011C  8FC20018   LW V0, 24(S8)
9D000120  00621023   SUBU V0, V1, V0
9D000124  AFC20010   SW V0, 16(S8)
75:                              x0 += sx;             //
9D000128  8FC30030   LW V1, 48(S8)
9D00012C  8FC2001C   LW V0, 28(S8)
9D000130  00621021   ADDU V0, V1, V0
9D000134  AFC20030   SW V0, 48(S8)
76:                          }                         //
77:                          if (err2 < deltaX) {      // check if the error is great enough to increment y0 (for more horizontal octants)
9D000138  8FC30024   LW V1, 36(S8)
9D00013C  8FC20014   LW V0, 20(S8)
9D000140  0062102A   SLT V0, V1, V0
9D000144  1040000B   BEQ V0, ZERO, 0x9D000174
9D000148  00000000   NOP
78:                              err += deltaX;        //
9D00014C  8FC30010   LW V1, 16(S8)
9D000150  8FC20014   LW V0, 20(S8)
9D000154  00621021   ADDU V0, V1, V0
9D000158  AFC20010   SW V0, 16(S8)
79:                              y0 += sy;             //
9D00015C  8FC30034   LW V1, 52(S8)
9D000160  8FC20020   LW V0, 32(S8)
9D000164  00621021   ADDU V0, V1, V0
9D000168  AFC20034   SW V0, 52(S8)
80:                          }
81:                      }
9D00016C  0B40002E   J 0x9D0000B8
9D000170  00000000   NOP
9D000174  0B40002E   J 0x9D0000B8
9D000178  00000000   NOP
82:                  }
9D00017C  03C0E821   ADDU SP, S8, ZERO
9D000180  8FBF002C   LW RA, 44(SP)
9D000184  8FBE0028   LW S8, 40(SP)
9D000188  27BD0030   ADDIU SP, SP, 48
9D00018C  03E00008   JR RA
9D000190  00000000   NOP
83:                  
84:                  /************************************************
85:                   * PlotVLine Function - This function plots a   *
86:                   * optimized vertical line.                     *
87:                   ************************************************/
88:                  void PlotVLine(int x, int y, int length, int color) {
9D000194  27BDFFE0   ADDIU SP, SP, -32
9D000198  AFBF001C   SW RA, 28(SP)
9D00019C  AFBE0018   SW S8, 24(SP)
9D0001A0  03A0F021   ADDU S8, SP, ZERO
9D0001A4  AFC40020   SW A0, 32(S8)
9D0001A8  AFC50024   SW A1, 36(S8)
9D0001AC  AFC60028   SW A2, 40(S8)
9D0001B0  AFC7002C   SW A3, 44(S8)
89:                      int t;
90:                      if(length<0){        // if length is negative 
9D0001B4  8FC20028   LW V0, 40(S8)
9D0001B8  04410008   BGEZ V0, 0x9D0001DC
9D0001BC  00000000   NOP
91:                          length=0-length; // swap length sign
9D0001C0  8FC20028   LW V0, 40(S8)
9D0001C4  00021023   SUBU V0, ZERO, V0
9D0001C8  AFC20028   SW V0, 40(S8)
92:                          y=y-length;      // swap y position
9D0001CC  8FC30024   LW V1, 36(S8)
9D0001D0  8FC20028   LW V0, 40(S8)
9D0001D4  00621023   SUBU V0, V1, V0
9D0001D8  AFC20024   SW V0, 36(S8)
93:                      }
94:                      for(t=0;t<length;t++)       // plot the vertical line
9D0001DC  AFC00010   SW ZERO, 16(S8)
9D0001E0  0B400085   J 0x9D000214
9D0001E4  00000000   NOP
9D000208  8FC20010   LW V0, 16(S8)
9D00020C  24420001   ADDIU V0, V0, 1
9D000210  AFC20010   SW V0, 16(S8)
9D000214  8FC30010   LW V1, 16(S8)
9D000218  8FC20028   LW V0, 40(S8)
9D00021C  0062102A   SLT V0, V1, V0
9D000220  1440FFF1   BNE V0, ZERO, 0x9D0001E8
9D000224  00000000   NOP
95:                          PlotPoint(x,y+t,color); //
9D0001E8  8FC30024   LW V1, 36(S8)
9D0001EC  8FC20010   LW V0, 16(S8)
9D0001F0  00621021   ADDU V0, V1, V0
9D0001F4  8FC40020   LW A0, 32(S8)
9D0001F8  00402821   ADDU A1, V0, ZERO
9D0001FC  8FC6002C   LW A2, 44(S8)
9D000200  0F4006F1   JAL PlotPoint
9D000204  00000000   NOP
96:                  }
9D000228  03C0E821   ADDU SP, S8, ZERO
9D00022C  8FBF001C   LW RA, 28(SP)
9D000230  8FBE0018   LW S8, 24(SP)
9D000234  27BD0020   ADDIU SP, SP, 32
9D000238  03E00008   JR RA
9D00023C  00000000   NOP
97:                  /************************************************
98:                   * PlotHLine Function - This function plots a   *
99:                   * optimized horizontal line.                   *
100:                  ************************************************/
101:                 void PlotHLine(int x, int y, int length, int color) {
9D000240  27BDFFE0   ADDIU SP, SP, -32
9D000244  AFBF001C   SW RA, 28(SP)
9D000248  AFBE0018   SW S8, 24(SP)
9D00024C  03A0F021   ADDU S8, SP, ZERO
9D000250  AFC40020   SW A0, 32(S8)
9D000254  AFC50024   SW A1, 36(S8)
9D000258  AFC60028   SW A2, 40(S8)
9D00025C  AFC7002C   SW A3, 44(S8)
102:                     int t;
103:                     if(length<0){        // if length is negative 
9D000260  8FC20028   LW V0, 40(S8)
9D000264  04410008   BGEZ V0, 0x9D000288
9D000268  00000000   NOP
104:                         length=0-length; // swap length sign
9D00026C  8FC20028   LW V0, 40(S8)
9D000270  00021023   SUBU V0, ZERO, V0
9D000274  AFC20028   SW V0, 40(S8)
105:                         x=x-length;      // swap y position
9D000278  8FC30020   LW V1, 32(S8)
9D00027C  8FC20028   LW V0, 40(S8)
9D000280  00621023   SUBU V0, V1, V0
9D000284  AFC20020   SW V0, 32(S8)
106:                     }
107:                     for(t=0;t<length;t++)       // plot the horizontal line
9D000288  AFC00010   SW ZERO, 16(S8)
9D00028C  0B4000B0   J 0x9D0002C0
9D000290  00000000   NOP
9D0002B4  8FC20010   LW V0, 16(S8)
9D0002B8  24420001   ADDIU V0, V0, 1
9D0002BC  AFC20010   SW V0, 16(S8)
9D0002C0  8FC30010   LW V1, 16(S8)
9D0002C4  8FC20028   LW V0, 40(S8)
9D0002C8  0062102A   SLT V0, V1, V0
9D0002CC  1440FFF1   BNE V0, ZERO, 0x9D000294
9D0002D0  00000000   NOP
108:                         PlotPoint(x+t,y,color); //
9D000294  8FC30020   LW V1, 32(S8)
9D000298  8FC20010   LW V0, 16(S8)
9D00029C  00621021   ADDU V0, V1, V0
9D0002A0  00402021   ADDU A0, V0, ZERO
9D0002A4  8FC50024   LW A1, 36(S8)
9D0002A8  8FC6002C   LW A2, 44(S8)
9D0002AC  0F4006F1   JAL PlotPoint
9D0002B0  00000000   NOP
109:                 }
9D0002D4  03C0E821   ADDU SP, S8, ZERO
9D0002D8  8FBF001C   LW RA, 28(SP)
9D0002DC  8FBE0018   LW S8, 24(SP)
9D0002E0  27BD0020   ADDIU SP, SP, 32
9D0002E4  03E00008   JR RA
9D0002E8  00000000   NOP
110:                 /************************************************
111:                  * PlotRectangle Function - This function plots *
112:                  * optimized rectangle.                         *
113:                  ************************************************/
114:                 void PlotRectangle(int x, int y, int w, int h, int color) {
9D0002EC  27BDFFE8   ADDIU SP, SP, -24
9D0002F0  AFBF0014   SW RA, 20(SP)
9D0002F4  AFBE0010   SW S8, 16(SP)
9D0002F8  03A0F021   ADDU S8, SP, ZERO
9D0002FC  AFC40018   SW A0, 24(S8)
9D000300  AFC5001C   SW A1, 28(S8)
9D000304  AFC60020   SW A2, 32(S8)
9D000308  AFC70024   SW A3, 36(S8)
115:                     PlotHLine(x,y,w,color);     // plot top line
9D00030C  8FC40018   LW A0, 24(S8)
9D000310  8FC5001C   LW A1, 28(S8)
9D000314  8FC60020   LW A2, 32(S8)
9D000318  8FC70028   LW A3, 40(S8)
9D00031C  0F400090   JAL PlotHLine
9D000320  00000000   NOP
116:                     PlotHLine(x,y+h-1,w,color); // plot bottom line
9D000324  8FC3001C   LW V1, 28(S8)
9D000328  8FC20024   LW V0, 36(S8)
9D00032C  00621021   ADDU V0, V1, V0
9D000330  2442FFFF   ADDIU V0, V0, -1
9D000334  8FC40018   LW A0, 24(S8)
9D000338  00402821   ADDU A1, V0, ZERO
9D00033C  8FC60020   LW A2, 32(S8)
9D000340  8FC70028   LW A3, 40(S8)
9D000344  0F400090   JAL PlotHLine
9D000348  00000000   NOP
117:                     PlotVLine(x,y,h,color);     // plot left line
9D00034C  8FC40018   LW A0, 24(S8)
9D000350  8FC5001C   LW A1, 28(S8)
9D000354  8FC60024   LW A2, 36(S8)
9D000358  8FC70028   LW A3, 40(S8)
9D00035C  0F400065   JAL PlotVLine
9D000360  00000000   NOP
118:                     PlotVLine(x+w-1,y,h,color); // plot right line
9D000364  8FC30018   LW V1, 24(S8)
9D000368  8FC20020   LW V0, 32(S8)
9D00036C  00621021   ADDU V0, V1, V0
9D000370  2442FFFF   ADDIU V0, V0, -1
9D000374  00402021   ADDU A0, V0, ZERO
9D000378  8FC5001C   LW A1, 28(S8)
9D00037C  8FC60024   LW A2, 36(S8)
9D000380  8FC70028   LW A3, 40(S8)
9D000384  0F400065   JAL PlotVLine
9D000388  00000000   NOP
119:                 }
9D00038C  03C0E821   ADDU SP, S8, ZERO
9D000390  8FBF0014   LW RA, 20(SP)
9D000394  8FBE0010   LW S8, 16(SP)
9D000398  27BD0018   ADDIU SP, SP, 24
9D00039C  03E00008   JR RA
9D0003A0  00000000   NOP
120:                 /************************************************
121:                  * PlotTriangle Function - This function plots  *
122:                  * triangle ABC.                                *
123:                  ************************************************/
124:                 void PlotTriangle(int xA, int yA, int xB, int yB, int xC, int yC, int color){
9D0003A4  27BDFFE0   ADDIU SP, SP, -32
9D0003A8  AFBF001C   SW RA, 28(SP)
9D0003AC  AFBE0018   SW S8, 24(SP)
9D0003B0  03A0F021   ADDU S8, SP, ZERO
9D0003B4  AFC40020   SW A0, 32(S8)
9D0003B8  AFC50024   SW A1, 36(S8)
9D0003BC  AFC60028   SW A2, 40(S8)
9D0003C0  AFC7002C   SW A3, 44(S8)
125:                     PlotLine(xA,yA,xB,yB,color); // plot first segment AB
9D0003C4  8FC20038   LW V0, 56(S8)
9D0003C8  AFA20010   SW V0, 16(SP)
9D0003CC  8FC40020   LW A0, 32(S8)
9D0003D0  8FC50024   LW A1, 36(S8)
9D0003D4  8FC60028   LW A2, 40(S8)
9D0003D8  8FC7002C   LW A3, 44(S8)
9D0003DC  0F400000   JAL PlotLine
9D0003E0  00000000   NOP
126:                     PlotLine(xB,yB,xC,yC,color); // plot second segment BC
9D0003E4  8FC20038   LW V0, 56(S8)
9D0003E8  AFA20010   SW V0, 16(SP)
9D0003EC  8FC40028   LW A0, 40(S8)
9D0003F0  8FC5002C   LW A1, 44(S8)
9D0003F4  8FC60030   LW A2, 48(S8)
9D0003F8  8FC70034   LW A3, 52(S8)
9D0003FC  0F400000   JAL PlotLine
9D000400  00000000   NOP
127:                     PlotLine(xA,yA,xC,yC,color); // plot third segment AC
9D000404  8FC20038   LW V0, 56(S8)
9D000408  AFA20010   SW V0, 16(SP)
9D00040C  8FC40020   LW A0, 32(S8)
9D000410  8FC50024   LW A1, 36(S8)
9D000414  8FC60030   LW A2, 48(S8)
9D000418  8FC70034   LW A3, 52(S8)
9D00041C  0F400000   JAL PlotLine
9D000420  00000000   NOP
128:                 }
9D000424  03C0E821   ADDU SP, S8, ZERO
9D000428  8FBF001C   LW RA, 28(SP)
9D00042C  8FBE0018   LW S8, 24(SP)
9D000430  27BD0020   ADDIU SP, SP, 32
9D000434  03E00008   JR RA
9D000438  00000000   NOP
129:                 /************************************************
130:                  * PlotCirculeQuadrant Function - This function *
131:                  * plots a quadrant of a circle at a given      *
132:                  * location (x,y). Quadrant numbers:            *
133:                  *     |                                        *
134:                  *   1 | 0                                      *
135:                  * ---------                                    *
136:                  *   2 | 3                                      *
137:                  *     |                                        *
138:                  * Function is based upon Bresenham's circle    *
139:                  * drawing algorithm.                           *
140:                  ************************************************/
141:                 int PlotCircleQuadrant(int x0, int y0, int r, int quad, int color) {
9D00043C  27BDFFD0   ADDIU SP, SP, -48
9D000440  AFBF002C   SW RA, 44(SP)
9D000444  AFBE0028   SW S8, 40(SP)
9D000448  03A0F021   ADDU S8, SP, ZERO
9D00044C  AFC40030   SW A0, 48(S8)
9D000450  AFC50034   SW A1, 52(S8)
9D000454  AFC60038   SW A2, 56(S8)
9D000458  AFC7003C   SW A3, 60(S8)
142:                    int x=r; 
9D00045C  8FC20038   LW V0, 56(S8)
9D000460  AFC20010   SW V0, 16(S8)
143:                    int y=0;
9D000464  AFC00014   SW ZERO, 20(S8)
144:                    int del_x=1-2*r; 
9D000468  8FC30038   LW V1, 56(S8)
9D00046C  00001021   ADDU V0, ZERO, ZERO
9D000470  00431023   SUBU V0, V0, V1
9D000474  00021040   SLL V0, V0, 1
9D000478  24420001   ADDIU V0, V0, 1
9D00047C  AFC20018   SW V0, 24(S8)
145:                    int del_y=1;
9D000480  24020001   ADDIU V0, ZERO, 1
9D000484  AFC2001C   SW V0, 28(S8)
146:                    int r_err=0;
9D000488  AFC00020   SW ZERO, 32(S8)
147:                    
148:                    if(quad<0 || quad>3)         // if sent a number that is not a quadrant 
9D00048C  8FC2003C   LW V0, 60(S8)
9D000490  04400005   BLTZ V0, 0x9D0004A8
9D000494  00000000   NOP
9D000498  8FC2003C   LW V0, 60(S8)
9D00049C  28420004   SLTI V0, V0, 4
9D0004A0  14400004   BNE V0, ZERO, 0x9D0004B4
9D0004A4  00000000   NOP
149:                        return(GDGL_OUTOFRANGE); // return error
9D0004A8  2402000B   ADDIU V0, ZERO, 11
9D0004AC  0B4001BF   J 0x9D0006FC
9D0004B0  00000000   NOP
150:                    
151:                    while (x>=y) {
9D0004B4  0B4001B9   J 0x9D0006E4
9D0004B8  00000000   NOP
9D0006E4  8FC30010   LW V1, 16(S8)
9D0006E8  8FC20014   LW V0, 20(S8)
9D0006EC  0062102A   SLT V0, V1, V0
9D0006F0  1040FF72   BEQ V0, ZERO, 0x9D0004BC
9D0006F4  00000000   NOP
152:                      switch(quad) {
9D0004BC  8FC2003C   LW V0, 60(S8)
9D0004C0  24030001   ADDIU V1, ZERO, 1
9D0004C4  1043003E   BEQ V0, V1, 0x9D0005C0
9D0004C8  00000000   NOP
9D0004CC  28430002   SLTI V1, V0, 2
9D0004D0  10600005   BEQ V1, ZERO, 0x9D0004E8
9D0004D4  00000000   NOP
9D0004D8  10400051   BEQ V0, ZERO, 0x9D000620
9D0004DC  00000000   NOP
9D0004E0  0B40019F   J 0x9D00067C
9D0004E4  00000000   NOP
9D0004E8  24030002   ADDIU V1, ZERO, 2
9D0004EC  1043001C   BEQ V0, V1, 0x9D000560
9D0004F0  00000000   NOP
9D0004F4  24030003   ADDIU V1, ZERO, 3
9D0004F8  14430060   BNE V0, V1, 0x9D00067C
9D0004FC  00000000   NOP
153:                            case 3:
154:                                PlotPoint(x0 + x, y0 + y,color); // third quadrant 
9D000500  8FC30030   LW V1, 48(S8)
9D000504  8FC20010   LW V0, 16(S8)
9D000508  00621821   ADDU V1, V1, V0
9D00050C  8FC40034   LW A0, 52(S8)
9D000510  8FC20014   LW V0, 20(S8)
9D000514  00821021   ADDU V0, A0, V0
9D000518  00602021   ADDU A0, V1, ZERO
9D00051C  00402821   ADDU A1, V0, ZERO
9D000520  8FC60040   LW A2, 64(S8)
9D000524  0F4006F1   JAL PlotPoint
9D000528  00000000   NOP
155:                                PlotPoint(x0 + y, y0 + x,color); // 
9D00052C  8FC30030   LW V1, 48(S8)
9D000530  8FC20014   LW V0, 20(S8)
9D000534  00621821   ADDU V1, V1, V0
9D000538  8FC40034   LW A0, 52(S8)
9D00053C  8FC20010   LW V0, 16(S8)
9D000540  00821021   ADDU V0, A0, V0
9D000544  00602021   ADDU A0, V1, ZERO
9D000548  00402821   ADDU A1, V0, ZERO
9D00054C  8FC60040   LW A2, 64(S8)
9D000550  0F4006F1   JAL PlotPoint
9D000554  00000000   NOP
156:                                break;
9D000558  0B40019F   J 0x9D00067C
9D00055C  00000000   NOP
157:                            case 2:
158:                                PlotPoint(x0 - y, y0 + x,color); // second quadrant
9D000560  8FC30030   LW V1, 48(S8)
9D000564  8FC20014   LW V0, 20(S8)
9D000568  00621823   SUBU V1, V1, V0
9D00056C  8FC40034   LW A0, 52(S8)
9D000570  8FC20010   LW V0, 16(S8)
9D000574  00821021   ADDU V0, A0, V0
9D000578  00602021   ADDU A0, V1, ZERO
9D00057C  00402821   ADDU A1, V0, ZERO
9D000580  8FC60040   LW A2, 64(S8)
9D000584  0F4006F1   JAL PlotPoint
9D000588  00000000   NOP
159:                                PlotPoint(x0 - x, y0 + y,color); // 
9D00058C  8FC30030   LW V1, 48(S8)
9D000590  8FC20010   LW V0, 16(S8)
9D000594  00621823   SUBU V1, V1, V0
9D000598  8FC40034   LW A0, 52(S8)
9D00059C  8FC20014   LW V0, 20(S8)
9D0005A0  00821021   ADDU V0, A0, V0
9D0005A4  00602021   ADDU A0, V1, ZERO
9D0005A8  00402821   ADDU A1, V0, ZERO
9D0005AC  8FC60040   LW A2, 64(S8)
9D0005B0  0F4006F1   JAL PlotPoint
9D0005B4  00000000   NOP
160:                                break;
9D0005B8  0B40019F   J 0x9D00067C
9D0005BC  00000000   NOP
161:                            case 1:
162:                                PlotPoint(x0 - x, y0 - y,color); // first quadrant
9D0005C0  8FC30030   LW V1, 48(S8)
9D0005C4  8FC20010   LW V0, 16(S8)
9D0005C8  00621823   SUBU V1, V1, V0
9D0005CC  8FC40034   LW A0, 52(S8)
9D0005D0  8FC20014   LW V0, 20(S8)
9D0005D4  00821023   SUBU V0, A0, V0
9D0005D8  00602021   ADDU A0, V1, ZERO
9D0005DC  00402821   ADDU A1, V0, ZERO
9D0005E0  8FC60040   LW A2, 64(S8)
9D0005E4  0F4006F1   JAL PlotPoint
9D0005E8  00000000   NOP
163:                                PlotPoint(x0 - y, y0 - x,color); // 
9D0005EC  8FC30030   LW V1, 48(S8)
9D0005F0  8FC20014   LW V0, 20(S8)
9D0005F4  00621823   SUBU V1, V1, V0
9D0005F8  8FC40034   LW A0, 52(S8)
9D0005FC  8FC20010   LW V0, 16(S8)
9D000600  00821023   SUBU V0, A0, V0
9D000604  00602021   ADDU A0, V1, ZERO
9D000608  00402821   ADDU A1, V0, ZERO
9D00060C  8FC60040   LW A2, 64(S8)
9D000610  0F4006F1   JAL PlotPoint
9D000614  00000000   NOP
164:                                break;
9D000618  0B40019F   J 0x9D00067C
9D00061C  00000000   NOP
165:                            case 0:
166:                                PlotPoint(x0 + y, y0 - x,color); // zero quadrant 
9D000620  8FC30030   LW V1, 48(S8)
9D000624  8FC20014   LW V0, 20(S8)
9D000628  00621821   ADDU V1, V1, V0
9D00062C  8FC40034   LW A0, 52(S8)
9D000630  8FC20010   LW V0, 16(S8)
9D000634  00821023   SUBU V0, A0, V0
9D000638  00602021   ADDU A0, V1, ZERO
9D00063C  00402821   ADDU A1, V0, ZERO
9D000640  8FC60040   LW A2, 64(S8)
9D000644  0F4006F1   JAL PlotPoint
9D000648  00000000   NOP
167:                                PlotPoint(x0 + x, y0 - y,color); // 
9D00064C  8FC30030   LW V1, 48(S8)
9D000650  8FC20010   LW V0, 16(S8)
9D000654  00621821   ADDU V1, V1, V0
9D000658  8FC40034   LW A0, 52(S8)
9D00065C  8FC20014   LW V0, 20(S8)
9D000660  00821023   SUBU V0, A0, V0
9D000664  00602021   ADDU A0, V1, ZERO
9D000668  00402821   ADDU A1, V0, ZERO
9D00066C  8FC60040   LW A2, 64(S8)
9D000670  0F4006F1   JAL PlotPoint
9D000674  00000000   NOP
168:                                break;
9D000678  00000000   NOP
169:                        }
170:                       y++;
9D00067C  8FC20014   LW V0, 20(S8)
9D000680  24420001   ADDIU V0, V0, 1
9D000684  AFC20014   SW V0, 20(S8)
171:                       r_err+=del_y;
9D000688  8FC30020   LW V1, 32(S8)
9D00068C  8FC2001C   LW V0, 28(S8)
9D000690  00621021   ADDU V0, V1, V0
9D000694  AFC20020   SW V0, 32(S8)
172:                       del_y+=2;
9D000698  8FC2001C   LW V0, 28(S8)
9D00069C  24420002   ADDIU V0, V0, 2
9D0006A0  AFC2001C   SW V0, 28(S8)
173:                       if((2*r_err + del_x)>0) {
9D0006A4  8FC20020   LW V0, 32(S8)
9D0006A8  00021840   SLL V1, V0, 1
9D0006AC  8FC20018   LW V0, 24(S8)
9D0006B0  00621021   ADDU V0, V1, V0
9D0006B4  1840000B   BLEZ V0, 0x9D0006E4
9D0006B8  00000000   NOP
174:                           x--;
9D0006BC  8FC20010   LW V0, 16(S8)
9D0006C0  2442FFFF   ADDIU V0, V0, -1
9D0006C4  AFC20010   SW V0, 16(S8)
175:                           r_err+=del_x;
9D0006C8  8FC30020   LW V1, 32(S8)
9D0006CC  8FC20018   LW V0, 24(S8)
9D0006D0  00621021   ADDU V0, V1, V0
9D0006D4  AFC20020   SW V0, 32(S8)
176:                           del_x+=2;
9D0006D8  8FC20018   LW V0, 24(S8)
9D0006DC  24420002   ADDIU V0, V0, 2
9D0006E0  AFC20018   SW V0, 24(S8)
177:                       }
178:                    }
179:                    return(GDGL_SUCCESS);
9D0006F8  2402000A   ADDIU V0, ZERO, 10
180:                 }
9D0006FC  03C0E821   ADDU SP, S8, ZERO
9D000700  8FBF002C   LW RA, 44(SP)
9D000704  8FBE0028   LW S8, 40(SP)
9D000708  27BD0030   ADDIU SP, SP, 48
9D00070C  03E00008   JR RA
9D000710  00000000   NOP
181:                 /************************************************
182:                  * PlotCircle Function - This function plots a  *
183:                  * circle with the center at x0,y0 and the      *
184:                  * radius r. This is based upon Bresenham's     *
185:                  * circle drawing algorithm.                    *
186:                  ************************************************/
187:                 int PlotCircle(int x0, int y0, int r, int color)  {
9D000714  27BDFFD0   ADDIU SP, SP, -48
9D000718  AFBF002C   SW RA, 44(SP)
9D00071C  AFBE0028   SW S8, 40(SP)
9D000720  03A0F021   ADDU S8, SP, ZERO
9D000724  AFC40030   SW A0, 48(S8)
9D000728  AFC50034   SW A1, 52(S8)
9D00072C  AFC60038   SW A2, 56(S8)
9D000730  AFC7003C   SW A3, 60(S8)
188:                    int x=r; 
9D000734  8FC20038   LW V0, 56(S8)
9D000738  AFC20010   SW V0, 16(S8)
189:                    int y=0;
9D00073C  AFC00014   SW ZERO, 20(S8)
190:                    int del_x=1-2*r; 
9D000740  8FC30038   LW V1, 56(S8)
9D000744  00001021   ADDU V0, ZERO, ZERO
9D000748  00431023   SUBU V0, V0, V1
9D00074C  00021040   SLL V0, V0, 1
9D000750  24420001   ADDIU V0, V0, 1
9D000754  AFC20018   SW V0, 24(S8)
191:                    int del_y=1;
9D000758  24020001   ADDIU V0, ZERO, 1
9D00075C  AFC2001C   SW V0, 28(S8)
192:                    int r_err=0;
9D000760  AFC00020   SW ZERO, 32(S8)
193:                    
194:                    if(r<0)                      // if function is sent a negative radius
9D000764  8FC20038   LW V0, 56(S8)
9D000768  04410004   BGEZ V0, 0x9D00077C
9D00076C  00000000   NOP
195:                        return(GDGL_OUTOFRANGE); //     return error 
9D000770  2402000B   ADDIU V0, ZERO, 11
9D000774  0B400259   J 0x9D000964
9D000778  00000000   NOP
196:                    
197:                    while (x>=y) {
9D00077C  0B400253   J 0x9D00094C
9D000780  00000000   NOP
9D00094C  8FC30010   LW V1, 16(S8)
9D000950  8FC20014   LW V0, 20(S8)
9D000954  0062102A   SLT V0, V1, V0
9D000958  1040FF8A   BEQ V0, ZERO, 0x9D000784
9D00095C  00000000   NOP
198:                       PlotPoint(x0 + x, y0 + y,color); // 3 plot all quadrants (circle drawn with symmetry)
9D000784  8FC30030   LW V1, 48(S8)
9D000788  8FC20010   LW V0, 16(S8)
9D00078C  00621821   ADDU V1, V1, V0
9D000790  8FC40034   LW A0, 52(S8)
9D000794  8FC20014   LW V0, 20(S8)
9D000798  00821021   ADDU V0, A0, V0
9D00079C  00602021   ADDU A0, V1, ZERO
9D0007A0  00402821   ADDU A1, V0, ZERO
9D0007A4  8FC6003C   LW A2, 60(S8)
9D0007A8  0F4006F1   JAL PlotPoint
9D0007AC  00000000   NOP
199:                       PlotPoint(x0 + y, y0 + x,color); // 3
9D0007B0  8FC30030   LW V1, 48(S8)
9D0007B4  8FC20014   LW V0, 20(S8)
9D0007B8  00621821   ADDU V1, V1, V0
9D0007BC  8FC40034   LW A0, 52(S8)
9D0007C0  8FC20010   LW V0, 16(S8)
9D0007C4  00821021   ADDU V0, A0, V0
9D0007C8  00602021   ADDU A0, V1, ZERO
9D0007CC  00402821   ADDU A1, V0, ZERO
9D0007D0  8FC6003C   LW A2, 60(S8)
9D0007D4  0F4006F1   JAL PlotPoint
9D0007D8  00000000   NOP
200:                       PlotPoint(x0 - y, y0 + x,color); // 2
9D0007DC  8FC30030   LW V1, 48(S8)
9D0007E0  8FC20014   LW V0, 20(S8)
9D0007E4  00621823   SUBU V1, V1, V0
9D0007E8  8FC40034   LW A0, 52(S8)
9D0007EC  8FC20010   LW V0, 16(S8)
9D0007F0  00821021   ADDU V0, A0, V0
9D0007F4  00602021   ADDU A0, V1, ZERO
9D0007F8  00402821   ADDU A1, V0, ZERO
9D0007FC  8FC6003C   LW A2, 60(S8)
9D000800  0F4006F1   JAL PlotPoint
9D000804  00000000   NOP
201:                       PlotPoint(x0 - x, y0 + y,color); // 2            
9D000808  8FC30030   LW V1, 48(S8)
9D00080C  8FC20010   LW V0, 16(S8)
9D000810  00621823   SUBU V1, V1, V0
9D000814  8FC40034   LW A0, 52(S8)
9D000818  8FC20014   LW V0, 20(S8)
9D00081C  00821021   ADDU V0, A0, V0
9D000820  00602021   ADDU A0, V1, ZERO
9D000824  00402821   ADDU A1, V0, ZERO
9D000828  8FC6003C   LW A2, 60(S8)
9D00082C  0F4006F1   JAL PlotPoint
9D000830  00000000   NOP
202:                       PlotPoint(x0 - x, y0 - y,color); // 1
9D000834  8FC30030   LW V1, 48(S8)
9D000838  8FC20010   LW V0, 16(S8)
9D00083C  00621823   SUBU V1, V1, V0
9D000840  8FC40034   LW A0, 52(S8)
9D000844  8FC20014   LW V0, 20(S8)
9D000848  00821023   SUBU V0, A0, V0
9D00084C  00602021   ADDU A0, V1, ZERO
9D000850  00402821   ADDU A1, V0, ZERO
9D000854  8FC6003C   LW A2, 60(S8)
9D000858  0F4006F1   JAL PlotPoint
9D00085C  00000000   NOP
203:                       PlotPoint(x0 - y, y0 - x,color); // 1
9D000860  8FC30030   LW V1, 48(S8)
9D000864  8FC20014   LW V0, 20(S8)
9D000868  00621823   SUBU V1, V1, V0
9D00086C  8FC40034   LW A0, 52(S8)
9D000870  8FC20010   LW V0, 16(S8)
9D000874  00821023   SUBU V0, A0, V0
9D000878  00602021   ADDU A0, V1, ZERO
9D00087C  00402821   ADDU A1, V0, ZERO
9D000880  8FC6003C   LW A2, 60(S8)
9D000884  0F4006F1   JAL PlotPoint
9D000888  00000000   NOP
204:                       PlotPoint(x0 + y, y0 - x,color); // 0
9D00088C  8FC30030   LW V1, 48(S8)
9D000890  8FC20014   LW V0, 20(S8)
9D000894  00621821   ADDU V1, V1, V0
9D000898  8FC40034   LW A0, 52(S8)
9D00089C  8FC20010   LW V0, 16(S8)
9D0008A0  00821023   SUBU V0, A0, V0
9D0008A4  00602021   ADDU A0, V1, ZERO
9D0008A8  00402821   ADDU A1, V0, ZERO
9D0008AC  8FC6003C   LW A2, 60(S8)
9D0008B0  0F4006F1   JAL PlotPoint
9D0008B4  00000000   NOP
205:                       PlotPoint(x0 + x, y0 - y,color); // 0
9D0008B8  8FC30030   LW V1, 48(S8)
9D0008BC  8FC20010   LW V0, 16(S8)
9D0008C0  00621821   ADDU V1, V1, V0
9D0008C4  8FC40034   LW A0, 52(S8)
9D0008C8  8FC20014   LW V0, 20(S8)
9D0008CC  00821023   SUBU V0, A0, V0
9D0008D0  00602021   ADDU A0, V1, ZERO
9D0008D4  00402821   ADDU A1, V0, ZERO
9D0008D8  8FC6003C   LW A2, 60(S8)
9D0008DC  0F4006F1   JAL PlotPoint
9D0008E0  00000000   NOP
206:                                 
207:                       y++;
9D0008E4  8FC20014   LW V0, 20(S8)
9D0008E8  24420001   ADDIU V0, V0, 1
9D0008EC  AFC20014   SW V0, 20(S8)
208:                       r_err+=del_y;
9D0008F0  8FC30020   LW V1, 32(S8)
9D0008F4  8FC2001C   LW V0, 28(S8)
9D0008F8  00621021   ADDU V0, V1, V0
9D0008FC  AFC20020   SW V0, 32(S8)
209:                       del_y+=2;
9D000900  8FC2001C   LW V0, 28(S8)
9D000904  24420002   ADDIU V0, V0, 2
9D000908  AFC2001C   SW V0, 28(S8)
210:                       if((2*r_err + del_x)>0) {
9D00090C  8FC20020   LW V0, 32(S8)
9D000910  00021840   SLL V1, V0, 1
9D000914  8FC20018   LW V0, 24(S8)
9D000918  00621021   ADDU V0, V1, V0
9D00091C  1840000B   BLEZ V0, 0x9D00094C
9D000920  00000000   NOP
211:                           x--;
9D000924  8FC20010   LW V0, 16(S8)
9D000928  2442FFFF   ADDIU V0, V0, -1
9D00092C  AFC20010   SW V0, 16(S8)
212:                           r_err+=del_x;
9D000930  8FC30020   LW V1, 32(S8)
9D000934  8FC20018   LW V0, 24(S8)
9D000938  00621021   ADDU V0, V1, V0
9D00093C  AFC20020   SW V0, 32(S8)
213:                           del_x+=2;
9D000940  8FC20018   LW V0, 24(S8)
9D000944  24420002   ADDIU V0, V0, 2
9D000948  AFC20018   SW V0, 24(S8)
214:                       }
215:                    }
216:                    return(GDGL_SUCCESS);
9D000960  2402000A   ADDIU V0, ZERO, 10
217:                 }
9D000964  03C0E821   ADDU SP, S8, ZERO
9D000968  8FBF002C   LW RA, 44(SP)
9D00096C  8FBE0028   LW S8, 40(SP)
9D000970  27BD0030   ADDIU SP, SP, 48
9D000974  03E00008   JR RA
9D000978  00000000   NOP
218:                 /************************************************
219:                  * PlotRoundRect Function - Plots a rectangle   *
220:                  * with rounded corners.                        *
221:                  ************************************************/
222:                 int PlotRoundedRect(int x, int y, int w, int h, int r, int color){
9D00097C  27BDFFE0   ADDIU SP, SP, -32
9D000980  AFBF001C   SW RA, 28(SP)
9D000984  AFBE0018   SW S8, 24(SP)
9D000988  03A0F021   ADDU S8, SP, ZERO
9D00098C  AFC40020   SW A0, 32(S8)
9D000990  AFC50024   SW A1, 36(S8)
9D000994  AFC60028   SW A2, 40(S8)
9D000998  AFC7002C   SW A3, 44(S8)
223:                     if(r<0)                      // if function is sent a negative radius
9D00099C  8FC20030   LW V0, 48(S8)
9D0009A0  04410004   BGEZ V0, 0x9D0009B4
9D0009A4  00000000   NOP
224:                         return(GDGL_OUTOFRANGE); //     return error 
9D0009A8  2402000B   ADDIU V0, ZERO, 11
9D0009AC  0B4002F8   J 0x9D000BE0
9D0009B0  00000000   NOP
225:                     
226:                     PlotHLine(x+r,y,w-2*r,color);     // plot top line
9D0009B4  8FC30020   LW V1, 32(S8)
9D0009B8  8FC20030   LW V0, 48(S8)
9D0009BC  00621821   ADDU V1, V1, V0
9D0009C0  8FC40030   LW A0, 48(S8)
9D0009C4  00001021   ADDU V0, ZERO, ZERO
9D0009C8  00441023   SUBU V0, V0, A0
9D0009CC  00021040   SLL V0, V0, 1
9D0009D0  00402021   ADDU A0, V0, ZERO
9D0009D4  8FC20028   LW V0, 40(S8)
9D0009D8  00821021   ADDU V0, A0, V0
9D0009DC  00602021   ADDU A0, V1, ZERO
9D0009E0  8FC50024   LW A1, 36(S8)
9D0009E4  00403021   ADDU A2, V0, ZERO
9D0009E8  8FC70034   LW A3, 52(S8)
9D0009EC  0F400090   JAL PlotHLine
9D0009F0  00000000   NOP
227:                     PlotHLine(x+r,y+h-1,w-2*r,color); // plot bottom line
9D0009F4  8FC30020   LW V1, 32(S8)
9D0009F8  8FC20030   LW V0, 48(S8)
9D0009FC  00622021   ADDU A0, V1, V0
9D000A00  8FC30024   LW V1, 36(S8)
9D000A04  8FC2002C   LW V0, 44(S8)
9D000A08  00621021   ADDU V0, V1, V0
9D000A0C  2443FFFF   ADDIU V1, V0, -1
9D000A10  8FC50030   LW A1, 48(S8)
9D000A14  00001021   ADDU V0, ZERO, ZERO
9D000A18  00451023   SUBU V0, V0, A1
9D000A1C  00021040   SLL V0, V0, 1
9D000A20  00402821   ADDU A1, V0, ZERO
9D000A24  8FC20028   LW V0, 40(S8)
9D000A28  00A21021   ADDU V0, A1, V0
9D000A2C  00602821   ADDU A1, V1, ZERO
9D000A30  00403021   ADDU A2, V0, ZERO
9D000A34  8FC70034   LW A3, 52(S8)
9D000A38  0F400090   JAL PlotHLine
9D000A3C  00000000   NOP
228:                     PlotVLine(x,y+r,h-2*r,color);     // plot left line
9D000A40  8FC30024   LW V1, 36(S8)
9D000A44  8FC20030   LW V0, 48(S8)
9D000A48  00621821   ADDU V1, V1, V0
9D000A4C  8FC40030   LW A0, 48(S8)
9D000A50  00001021   ADDU V0, ZERO, ZERO
9D000A54  00441023   SUBU V0, V0, A0
9D000A58  00021040   SLL V0, V0, 1
9D000A5C  00402021   ADDU A0, V0, ZERO
9D000A60  8FC2002C   LW V0, 44(S8)
9D000A64  00821021   ADDU V0, A0, V0
9D000A68  8FC40020   LW A0, 32(S8)
9D000A6C  00602821   ADDU A1, V1, ZERO
9D000A70  00403021   ADDU A2, V0, ZERO
9D000A74  8FC70034   LW A3, 52(S8)
9D000A78  0F400065   JAL PlotVLine
9D000A7C  00000000   NOP
229:                     PlotVLine(x+w-1,y+r,h-2*r,color); // plot right line
9D000A80  8FC30020   LW V1, 32(S8)
9D000A84  8FC20028   LW V0, 40(S8)
9D000A88  00621021   ADDU V0, V1, V0
9D000A8C  2444FFFF   ADDIU A0, V0, -1
9D000A90  8FC30024   LW V1, 36(S8)
9D000A94  8FC20030   LW V0, 48(S8)
9D000A98  00621821   ADDU V1, V1, V0
9D000A9C  8FC50030   LW A1, 48(S8)
9D000AA0  00001021   ADDU V0, ZERO, ZERO
9D000AA4  00451023   SUBU V0, V0, A1
9D000AA8  00021040   SLL V0, V0, 1
9D000AAC  00402821   ADDU A1, V0, ZERO
9D000AB0  8FC2002C   LW V0, 44(S8)
9D000AB4  00A21021   ADDU V0, A1, V0
9D000AB8  00602821   ADDU A1, V1, ZERO
9D000ABC  00403021   ADDU A2, V0, ZERO
9D000AC0  8FC70034   LW A3, 52(S8)
9D000AC4  0F400065   JAL PlotVLine
9D000AC8  00000000   NOP
230:                     
231:                     PlotCircleQuadrant(x+r,y+r,r,1,color);         // plot top left (quad 1) 
9D000ACC  8FC30020   LW V1, 32(S8)
9D000AD0  8FC20030   LW V0, 48(S8)
9D000AD4  00621821   ADDU V1, V1, V0
9D000AD8  8FC40024   LW A0, 36(S8)
9D000ADC  8FC20030   LW V0, 48(S8)
9D000AE0  00821021   ADDU V0, A0, V0
9D000AE4  8FC40034   LW A0, 52(S8)
9D000AE8  AFA40010   SW A0, 16(SP)
9D000AEC  00602021   ADDU A0, V1, ZERO
9D000AF0  00402821   ADDU A1, V0, ZERO
9D000AF4  8FC60030   LW A2, 48(S8)
9D000AF8  24070001   ADDIU A3, ZERO, 1
9D000AFC  0F40010F   JAL PlotCircleQuadrant
9D000B00  00000000   NOP
232:                     PlotCircleQuadrant(x+w-r-1,y+r,r,0,color);     // plot top right (quad 0)
9D000B04  8FC30020   LW V1, 32(S8)
9D000B08  8FC20028   LW V0, 40(S8)
9D000B0C  00621821   ADDU V1, V1, V0
9D000B10  8FC20030   LW V0, 48(S8)
9D000B14  00621023   SUBU V0, V1, V0
9D000B18  2443FFFF   ADDIU V1, V0, -1
9D000B1C  8FC40024   LW A0, 36(S8)
9D000B20  8FC20030   LW V0, 48(S8)
9D000B24  00821021   ADDU V0, A0, V0
9D000B28  8FC40034   LW A0, 52(S8)
9D000B2C  AFA40010   SW A0, 16(SP)
9D000B30  00602021   ADDU A0, V1, ZERO
9D000B34  00402821   ADDU A1, V0, ZERO
9D000B38  8FC60030   LW A2, 48(S8)
9D000B3C  00003821   ADDU A3, ZERO, ZERO
9D000B40  0F40010F   JAL PlotCircleQuadrant
9D000B44  00000000   NOP
233:                     PlotCircleQuadrant(x+w-r-1,y+h-r-1,r,3,color); // plot bottom right (quad 3)      
9D000B48  8FC30020   LW V1, 32(S8)
9D000B4C  8FC20028   LW V0, 40(S8)
9D000B50  00621821   ADDU V1, V1, V0
9D000B54  8FC20030   LW V0, 48(S8)
9D000B58  00621023   SUBU V0, V1, V0
9D000B5C  2443FFFF   ADDIU V1, V0, -1
9D000B60  8FC40024   LW A0, 36(S8)
9D000B64  8FC2002C   LW V0, 44(S8)
9D000B68  00822021   ADDU A0, A0, V0
9D000B6C  8FC20030   LW V0, 48(S8)
9D000B70  00821023   SUBU V0, A0, V0
9D000B74  2442FFFF   ADDIU V0, V0, -1
9D000B78  8FC40034   LW A0, 52(S8)
9D000B7C  AFA40010   SW A0, 16(SP)
9D000B80  00602021   ADDU A0, V1, ZERO
9D000B84  00402821   ADDU A1, V0, ZERO
9D000B88  8FC60030   LW A2, 48(S8)
9D000B8C  24070003   ADDIU A3, ZERO, 3
9D000B90  0F40010F   JAL PlotCircleQuadrant
9D000B94  00000000   NOP
234:                     PlotCircleQuadrant(x+r,y+h-r-1,r,2,color);     // plot bottom left (quad 2)
9D000B98  8FC30020   LW V1, 32(S8)
9D000B9C  8FC20030   LW V0, 48(S8)
9D000BA0  00621821   ADDU V1, V1, V0
9D000BA4  8FC40024   LW A0, 36(S8)
9D000BA8  8FC2002C   LW V0, 44(S8)
9D000BAC  00822021   ADDU A0, A0, V0
9D000BB0  8FC20030   LW V0, 48(S8)
9D000BB4  00821023   SUBU V0, A0, V0
9D000BB8  2442FFFF   ADDIU V0, V0, -1
9D000BBC  8FC40034   LW A0, 52(S8)
9D000BC0  AFA40010   SW A0, 16(SP)
9D000BC4  00602021   ADDU A0, V1, ZERO
9D000BC8  00402821   ADDU A1, V0, ZERO
9D000BCC  8FC60030   LW A2, 48(S8)
9D000BD0  24070002   ADDIU A3, ZERO, 2
9D000BD4  0F40010F   JAL PlotCircleQuadrant
9D000BD8  00000000   NOP
235:                     return(GDGL_SUCCESS);
9D000BDC  2402000A   ADDIU V0, ZERO, 10
236:                 }
9D000BE0  03C0E821   ADDU SP, S8, ZERO
9D000BE4  8FBF001C   LW RA, 28(SP)
9D000BE8  8FBE0018   LW S8, 24(SP)
9D000BEC  27BD0020   ADDIU SP, SP, 32
9D000BF0  03E00008   JR RA
9D000BF4  00000000   NOP
237:                 /************************************************
238:                  * PlotFilledRectangle Function - Plots a       *
239:                  * filled rectangle.                            *
240:                  ************************************************/
241:                 void PlotFilledRectangle(int x, int y, int w, int h, int color) {
9D000BF8  27BDFFE0   ADDIU SP, SP, -32
9D000BFC  AFBF001C   SW RA, 28(SP)
9D000C00  AFBE0018   SW S8, 24(SP)
9D000C04  03A0F021   ADDU S8, SP, ZERO
9D000C08  AFC40020   SW A0, 32(S8)
9D000C0C  AFC50024   SW A1, 36(S8)
9D000C10  AFC60028   SW A2, 40(S8)
9D000C14  AFC7002C   SW A3, 44(S8)
242:                     int z;
243:                     for(z=x;z<w+x;z++)          // plot the rectangle with vertical lines 
9D000C18  8FC20020   LW V0, 32(S8)
9D000C1C  AFC20010   SW V0, 16(S8)
9D000C20  0B400313   J 0x9D000C4C
9D000C24  00000000   NOP
9D000C40  8FC20010   LW V0, 16(S8)
9D000C44  24420001   ADDIU V0, V0, 1
9D000C48  AFC20010   SW V0, 16(S8)
9D000C4C  8FC30028   LW V1, 40(S8)
9D000C50  8FC20020   LW V0, 32(S8)
9D000C54  00621821   ADDU V1, V1, V0
9D000C58  8FC20010   LW V0, 16(S8)
9D000C5C  0043102A   SLT V0, V0, V1
9D000C60  1440FFF1   BNE V0, ZERO, 0x9D000C28
9D000C64  00000000   NOP
244:                         PlotVLine(z,y,h,color); // 
9D000C28  8FC40010   LW A0, 16(S8)
9D000C2C  8FC50024   LW A1, 36(S8)
9D000C30  8FC6002C   LW A2, 44(S8)
9D000C34  8FC70030   LW A3, 48(S8)
9D000C38  0F400065   JAL PlotVLine
9D000C3C  00000000   NOP
245:                 }
9D000C68  03C0E821   ADDU SP, S8, ZERO
9D000C6C  8FBF001C   LW RA, 28(SP)
9D000C70  8FBE0018   LW S8, 24(SP)
9D000C74  27BD0020   ADDIU SP, SP, 32
9D000C78  03E00008   JR RA
9D000C7C  00000000   NOP
246:                 /************************************************
247:                  * PlotRoundFilledSide Function - Function      *
248:                  * plots a rectangle side with rounded corners. *
249:                  * 0 = right, 1 = left. This is based upon      *
250:                  * Bresenham's circle drawing algorithm.        *                    
251:                  ************************************************/
252:                 void PlotRoundFilledSide(int x0, int y0, int r, int h, int RorL, int color){
9D000C80  27BDFFD0   ADDIU SP, SP, -48
9D000C84  AFBF002C   SW RA, 44(SP)
9D000C88  AFBE0028   SW S8, 40(SP)
9D000C8C  03A0F021   ADDU S8, SP, ZERO
9D000C90  AFC40030   SW A0, 48(S8)
9D000C94  AFC50034   SW A1, 52(S8)
9D000C98  AFC60038   SW A2, 56(S8)
9D000C9C  AFC7003C   SW A3, 60(S8)
253:                     int x=r; 
9D000CA0  8FC20038   LW V0, 56(S8)
9D000CA4  AFC20010   SW V0, 16(S8)
254:                     int y=0;
9D000CA8  AFC00014   SW ZERO, 20(S8)
255:                     int del_x=1-2*r; 
9D000CAC  8FC30038   LW V1, 56(S8)
9D000CB0  00001021   ADDU V0, ZERO, ZERO
9D000CB4  00431023   SUBU V0, V0, V1
9D000CB8  00021040   SLL V0, V0, 1
9D000CBC  24420001   ADDIU V0, V0, 1
9D000CC0  AFC20018   SW V0, 24(S8)
256:                     int del_y=1;
9D000CC4  24020001   ADDIU V0, ZERO, 1
9D000CC8  AFC2001C   SW V0, 28(S8)
257:                     int r_err=0;
9D000CCC  AFC00020   SW ZERO, 32(S8)
258:                    
259:                     while (x>=y) {
9D000CD0  0B400397   J 0x9D000E5C
9D000CD4  00000000   NOP
9D000E5C  8FC30010   LW V1, 16(S8)
9D000E60  8FC20014   LW V0, 20(S8)
9D000E64  0062102A   SLT V0, V1, V0
9D000E68  1040FF9B   BEQ V0, ZERO, 0x9D000CD8
9D000E6C  00000000   NOP
260:                         if (RorL==0) {
9D000CD8  8FC20040   LW V0, 64(S8)
9D000CDC  14400021   BNE V0, ZERO, 0x9D000D64
9D000CE0  00000000   NOP
261:                             PlotVLine(x0+x, y0-y, 2*y+1+h, color);
9D000CE4  8FC30030   LW V1, 48(S8)
9D000CE8  8FC20010   LW V0, 16(S8)
9D000CEC  00622021   ADDU A0, V1, V0
9D000CF0  8FC30034   LW V1, 52(S8)
9D000CF4  8FC20014   LW V0, 20(S8)
9D000CF8  00621823   SUBU V1, V1, V0
9D000CFC  8FC20014   LW V0, 20(S8)
9D000D00  00021040   SLL V0, V0, 1
9D000D04  24450001   ADDIU A1, V0, 1
9D000D08  8FC2003C   LW V0, 60(S8)
9D000D0C  00A21021   ADDU V0, A1, V0
9D000D10  00602821   ADDU A1, V1, ZERO
9D000D14  00403021   ADDU A2, V0, ZERO
9D000D18  8FC70044   LW A3, 68(S8)
9D000D1C  0F400065   JAL PlotVLine
9D000D20  00000000   NOP
262:                             PlotVLine(x0+y, y0-x, 2*x+1+h, color);
9D000D24  8FC30030   LW V1, 48(S8)
9D000D28  8FC20014   LW V0, 20(S8)
9D000D2C  00622021   ADDU A0, V1, V0
9D000D30  8FC30034   LW V1, 52(S8)
9D000D34  8FC20010   LW V0, 16(S8)
9D000D38  00621823   SUBU V1, V1, V0
9D000D3C  8FC20010   LW V0, 16(S8)
9D000D40  00021040   SLL V0, V0, 1
9D000D44  24450001   ADDIU A1, V0, 1
9D000D48  8FC2003C   LW V0, 60(S8)
9D000D4C  00A21021   ADDU V0, A1, V0
9D000D50  00602821   ADDU A1, V1, ZERO
9D000D54  00403021   ADDU A2, V0, ZERO
9D000D58  8FC70044   LW A3, 68(S8)
9D000D5C  0F400065   JAL PlotVLine
9D000D60  00000000   NOP
263:                         }
264:                         if (RorL==1) {
9D000D64  8FC30040   LW V1, 64(S8)
9D000D68  24020001   ADDIU V0, ZERO, 1
9D000D6C  14620021   BNE V1, V0, 0x9D000DF4
9D000D70  00000000   NOP
265:                             PlotVLine(x0-x, y0-y, 2*y+1+h, color);
9D000D74  8FC30030   LW V1, 48(S8)
9D000D78  8FC20010   LW V0, 16(S8)
9D000D7C  00622023   SUBU A0, V1, V0
9D000D80  8FC30034   LW V1, 52(S8)
9D000D84  8FC20014   LW V0, 20(S8)
9D000D88  00621823   SUBU V1, V1, V0
9D000D8C  8FC20014   LW V0, 20(S8)
9D000D90  00021040   SLL V0, V0, 1
9D000D94  24450001   ADDIU A1, V0, 1
9D000D98  8FC2003C   LW V0, 60(S8)
9D000D9C  00A21021   ADDU V0, A1, V0
9D000DA0  00602821   ADDU A1, V1, ZERO
9D000DA4  00403021   ADDU A2, V0, ZERO
9D000DA8  8FC70044   LW A3, 68(S8)
9D000DAC  0F400065   JAL PlotVLine
9D000DB0  00000000   NOP
266:                             PlotVLine(x0-y, y0-x, 2*x+1+h, color);
9D000DB4  8FC30030   LW V1, 48(S8)
9D000DB8  8FC20014   LW V0, 20(S8)
9D000DBC  00622023   SUBU A0, V1, V0
9D000DC0  8FC30034   LW V1, 52(S8)
9D000DC4  8FC20010   LW V0, 16(S8)
9D000DC8  00621823   SUBU V1, V1, V0
9D000DCC  8FC20010   LW V0, 16(S8)
9D000DD0  00021040   SLL V0, V0, 1
9D000DD4  24450001   ADDIU A1, V0, 1
9D000DD8  8FC2003C   LW V0, 60(S8)
9D000DDC  00A21021   ADDU V0, A1, V0
9D000DE0  00602821   ADDU A1, V1, ZERO
9D000DE4  00403021   ADDU A2, V0, ZERO
9D000DE8  8FC70044   LW A3, 68(S8)
9D000DEC  0F400065   JAL PlotVLine
9D000DF0  00000000   NOP
267:                         } 
268:                                 
269:                       y++;
9D000DF4  8FC20014   LW V0, 20(S8)
9D000DF8  24420001   ADDIU V0, V0, 1
9D000DFC  AFC20014   SW V0, 20(S8)
270:                       r_err+=del_y;
9D000E00  8FC30020   LW V1, 32(S8)
9D000E04  8FC2001C   LW V0, 28(S8)
9D000E08  00621021   ADDU V0, V1, V0
9D000E0C  AFC20020   SW V0, 32(S8)
271:                       del_y+=2;
9D000E10  8FC2001C   LW V0, 28(S8)
9D000E14  24420002   ADDIU V0, V0, 2
9D000E18  AFC2001C   SW V0, 28(S8)
272:                       if((2*r_err + del_x)>0) {
9D000E1C  8FC20020   LW V0, 32(S8)
9D000E20  00021840   SLL V1, V0, 1
9D000E24  8FC20018   LW V0, 24(S8)
9D000E28  00621021   ADDU V0, V1, V0
9D000E2C  1840000B   BLEZ V0, 0x9D000E5C
9D000E30  00000000   NOP
273:                           x--;
9D000E34  8FC20010   LW V0, 16(S8)
9D000E38  2442FFFF   ADDIU V0, V0, -1
9D000E3C  AFC20010   SW V0, 16(S8)
274:                           r_err+=del_x;
9D000E40  8FC30020   LW V1, 32(S8)
9D000E44  8FC20018   LW V0, 24(S8)
9D000E48  00621021   ADDU V0, V1, V0
9D000E4C  AFC20020   SW V0, 32(S8)
275:                           del_x+=2;
9D000E50  8FC20018   LW V0, 24(S8)
9D000E54  24420002   ADDIU V0, V0, 2
9D000E58  AFC20018   SW V0, 24(S8)
276:                       }
277:                    }
278:                 }
9D000E70  03C0E821   ADDU SP, S8, ZERO
9D000E74  8FBF002C   LW RA, 44(SP)
9D000E78  8FBE0028   LW S8, 40(SP)
9D000E7C  27BD0030   ADDIU SP, SP, 48
9D000E80  03E00008   JR RA
9D000E84  00000000   NOP
279:                 
280:                 /************************************************
281:                  * PlotFilledRoundedRect Function - Function    *
282:                  * plots a rectangle with rounded corners.      *
283:                  ************************************************/
284:                 int PlotFilledRoundedRect(int x0, int y0, int w, int h, int r, int color) {
9D000E88  27BDFFD8   ADDIU SP, SP, -40
9D000E8C  AFBF0024   SW RA, 36(SP)
9D000E90  AFBE0020   SW S8, 32(SP)
9D000E94  03A0F021   ADDU S8, SP, ZERO
9D000E98  AFC40028   SW A0, 40(S8)
9D000E9C  AFC5002C   SW A1, 44(S8)
9D000EA0  AFC60030   SW A2, 48(S8)
9D000EA4  AFC70034   SW A3, 52(S8)
285:                     int z;
286:                     if(r<0)                      // if function is sent a negative radius value 
9D000EA8  8FC20038   LW V0, 56(S8)
9D000EAC  04410004   BGEZ V0, 0x9D000EC0
9D000EB0  00000000   NOP
287:                         return(GDGL_OUTOFRANGE); //     return error 
9D000EB4  2402000B   ADDIU V0, ZERO, 11
9D000EB8  0B4003FF   J 0x9D000FFC
9D000EBC  00000000   NOP
288:                     
289:                     for(z=y0;z<h+y0;z++)                  // plot center of the rounded rectangle 
9D000EC0  8FC2002C   LW V0, 44(S8)
9D000EC4  AFC20018   SW V0, 24(S8)
9D000EC8  0B4003C7   J 0x9D000F1C
9D000ECC  00000000   NOP
9D000F10  8FC20018   LW V0, 24(S8)
9D000F14  24420001   ADDIU V0, V0, 1
9D000F18  AFC20018   SW V0, 24(S8)
9D000F1C  8FC30034   LW V1, 52(S8)
9D000F20  8FC2002C   LW V0, 44(S8)
9D000F24  00621821   ADDU V1, V1, V0
9D000F28  8FC20018   LW V0, 24(S8)
9D000F2C  0043102A   SLT V0, V0, V1
9D000F30  1440FFE7   BNE V0, ZERO, 0x9D000ED0
9D000F34  00000000   NOP
290:                         PlotHLine(x0+r,z,w-2*r,color);    //
9D000ED0  8FC30028   LW V1, 40(S8)
9D000ED4  8FC20038   LW V0, 56(S8)
9D000ED8  00621821   ADDU V1, V1, V0
9D000EDC  8FC40038   LW A0, 56(S8)
9D000EE0  00001021   ADDU V0, ZERO, ZERO
9D000EE4  00441023   SUBU V0, V0, A0
9D000EE8  00021040   SLL V0, V0, 1
9D000EEC  00402021   ADDU A0, V0, ZERO
9D000EF0  8FC20030   LW V0, 48(S8)
9D000EF4  00821021   ADDU V0, A0, V0
9D000EF8  00602021   ADDU A0, V1, ZERO
9D000EFC  8FC50018   LW A1, 24(S8)
9D000F00  00403021   ADDU A2, V0, ZERO
9D000F04  8FC7003C   LW A3, 60(S8)
9D000F08  0F400090   JAL PlotHLine
9D000F0C  00000000   NOP
291:                     
292:                     PlotRoundFilledSide(x0+w-r-1, y0+r, r, h-2*r-1, 0, color); // plot right side 
9D000F38  8FC30028   LW V1, 40(S8)
9D000F3C  8FC20030   LW V0, 48(S8)
9D000F40  00621821   ADDU V1, V1, V0
9D000F44  8FC20038   LW V0, 56(S8)
9D000F48  00621023   SUBU V0, V1, V0
9D000F4C  2444FFFF   ADDIU A0, V0, -1
9D000F50  8FC3002C   LW V1, 44(S8)
9D000F54  8FC20038   LW V0, 56(S8)
9D000F58  00621821   ADDU V1, V1, V0
9D000F5C  8FC50038   LW A1, 56(S8)
9D000F60  00001021   ADDU V0, ZERO, ZERO
9D000F64  00451023   SUBU V0, V0, A1
9D000F68  00021040   SLL V0, V0, 1
9D000F6C  00402821   ADDU A1, V0, ZERO
9D000F70  8FC20034   LW V0, 52(S8)
9D000F74  00A21021   ADDU V0, A1, V0
9D000F78  2442FFFF   ADDIU V0, V0, -1
9D000F7C  AFA00010   SW ZERO, 16(SP)
9D000F80  8FC5003C   LW A1, 60(S8)
9D000F84  AFA50014   SW A1, 20(SP)
9D000F88  00602821   ADDU A1, V1, ZERO
9D000F8C  8FC60038   LW A2, 56(S8)
9D000F90  00403821   ADDU A3, V0, ZERO
9D000F94  0F400320   JAL PlotRoundFilledSide
9D000F98  00000000   NOP
293:                     PlotRoundFilledSide(x0+r,     y0+r, r, h-2*r-1, 1, color); // plot left side 
9D000F9C  8FC30028   LW V1, 40(S8)
9D000FA0  8FC20038   LW V0, 56(S8)
9D000FA4  00622021   ADDU A0, V1, V0
9D000FA8  8FC3002C   LW V1, 44(S8)
9D000FAC  8FC20038   LW V0, 56(S8)
9D000FB0  00621821   ADDU V1, V1, V0
9D000FB4  8FC50038   LW A1, 56(S8)
9D000FB8  00001021   ADDU V0, ZERO, ZERO
9D000FBC  00451023   SUBU V0, V0, A1
9D000FC0  00021040   SLL V0, V0, 1
9D000FC4  00402821   ADDU A1, V0, ZERO
9D000FC8  8FC20034   LW V0, 52(S8)
9D000FCC  00A21021   ADDU V0, A1, V0
9D000FD0  2442FFFF   ADDIU V0, V0, -1
9D000FD4  24050001   ADDIU A1, ZERO, 1
9D000FD8  AFA50010   SW A1, 16(SP)
9D000FDC  8FC5003C   LW A1, 60(S8)
9D000FE0  AFA50014   SW A1, 20(SP)
9D000FE4  00602821   ADDU A1, V1, ZERO
9D000FE8  8FC60038   LW A2, 56(S8)
9D000FEC  00403821   ADDU A3, V0, ZERO
9D000FF0  0F400320   JAL PlotRoundFilledSide
9D000FF4  00000000   NOP
294:                     return(GDGL_SUCCESS);
9D000FF8  2402000A   ADDIU V0, ZERO, 10
295:                 }
9D000FFC  03C0E821   ADDU SP, S8, ZERO
9D001000  8FBF0024   LW RA, 36(SP)
9D001004  8FBE0020   LW S8, 32(SP)
9D001008  27BD0028   ADDIU SP, SP, 40
9D00100C  03E00008   JR RA
9D001010  00000000   NOP
296:                 
297:                 /************************************************
298:                  * PlotFilledRoundedRect Function - Function    *
299:                  * plots a rectangle with rounded corners.      *
300:                  ************************************************/
301:                 int PlotFilledCircle(int x0, int y0, int r, int color){
9D001014  27BDFFE0   ADDIU SP, SP, -32
9D001018  AFBF001C   SW RA, 28(SP)
9D00101C  AFBE0018   SW S8, 24(SP)
9D001020  03A0F021   ADDU S8, SP, ZERO
9D001024  AFC40020   SW A0, 32(S8)
9D001028  AFC50024   SW A1, 36(S8)
9D00102C  AFC60028   SW A2, 40(S8)
9D001030  AFC7002C   SW A3, 44(S8)
302:                     if(r<0)                      // if function is sent a negative radius value
9D001034  8FC20028   LW V0, 40(S8)
9D001038  04410004   BGEZ V0, 0x9D00104C
9D00103C  00000000   NOP
303:                         return(GDGL_OUTOFRANGE); //     return error 
9D001040  2402000B   ADDIU V0, ZERO, 11
9D001044  0B400433   J 0x9D0010CC
9D001048  00000000   NOP
304:                     
305:                     PlotVLine(x0, y0-r, 2*r+1, color);
9D00104C  8FC30024   LW V1, 36(S8)
9D001050  8FC20028   LW V0, 40(S8)
9D001054  00621823   SUBU V1, V1, V0
9D001058  8FC20028   LW V0, 40(S8)
9D00105C  00021040   SLL V0, V0, 1
9D001060  24420001   ADDIU V0, V0, 1
9D001064  8FC40020   LW A0, 32(S8)
9D001068  00602821   ADDU A1, V1, ZERO
9D00106C  00403021   ADDU A2, V0, ZERO
9D001070  8FC7002C   LW A3, 44(S8)
9D001074  0F400065   JAL PlotVLine
9D001078  00000000   NOP
306:                     PlotRoundFilledSide(x0, y0, r, 0, 0, color); // plot right side
9D00107C  AFA00010   SW ZERO, 16(SP)
9D001080  8FC2002C   LW V0, 44(S8)
9D001084  AFA20014   SW V0, 20(SP)
9D001088  8FC40020   LW A0, 32(S8)
9D00108C  8FC50024   LW A1, 36(S8)
9D001090  8FC60028   LW A2, 40(S8)
9D001094  00003821   ADDU A3, ZERO, ZERO
9D001098  0F400320   JAL PlotRoundFilledSide
9D00109C  00000000   NOP
307:                     PlotRoundFilledSide(x0, y0, r, 0, 1, color); // plot left side 
9D0010A0  24020001   ADDIU V0, ZERO, 1
9D0010A4  AFA20010   SW V0, 16(SP)
9D0010A8  8FC2002C   LW V0, 44(S8)
9D0010AC  AFA20014   SW V0, 20(SP)
9D0010B0  8FC40020   LW A0, 32(S8)
9D0010B4  8FC50024   LW A1, 36(S8)
9D0010B8  8FC60028   LW A2, 40(S8)
9D0010BC  00003821   ADDU A3, ZERO, ZERO
9D0010C0  0F400320   JAL PlotRoundFilledSide
9D0010C4  00000000   NOP
308:                     return(GDGL_SUCCESS);
9D0010C8  2402000A   ADDIU V0, ZERO, 10
309:                 }
9D0010CC  03C0E821   ADDU SP, S8, ZERO
9D0010D0  8FBF001C   LW RA, 28(SP)
9D0010D4  8FBE0018   LW S8, 24(SP)
9D0010D8  27BD0020   ADDIU SP, SP, 32
9D0010DC  03E00008   JR RA
9D0010E0  00000000   NOP
310:                 
311:                 /*******************************************************************************
312:                  * Text drawing functions past this point.                                     *
313:                  *******************************************************************************/
314:                 /************************************************
315:                  * WriteChar Function - function plots a single *
316:                  * character.                                   *
317:                  ************************************************/
318:                 int WriteChar(int x0, int y0, unsigned char letter, int color, int backcolor){
9D0010E4  27BDFFD0   ADDIU SP, SP, -48
9D0010E8  AFBF002C   SW RA, 44(SP)
9D0010EC  AFBE0028   SW S8, 40(SP)
9D0010F0  03A0F021   ADDU S8, SP, ZERO
9D0010F4  AFC40030   SW A0, 48(S8)
9D0010F8  AFC50034   SW A1, 52(S8)
9D0010FC  00C01021   ADDU V0, A2, ZERO
9D001100  AFC7003C   SW A3, 60(S8)
9D001104  A3C20038   SB V0, 56(S8)
319:                     int x,y,ySize,xSize;
320:                     unsigned char mask;
321:                     
322:                     if(letter<0x20||letter>0x7E) // if function is sent a ASCII character it can't print
9D001108  93C20038   LBU V0, 56(S8)
9D00110C  2C420020   SLTIU V0, V0, 32
9D001110  14400005   BNE V0, ZERO, 0x9D001128
9D001114  00000000   NOP
9D001118  93C20038   LBU V0, 56(S8)
9D00111C  2C42007F   SLTIU V0, V0, 127
9D001120  14400004   BNE V0, ZERO, 0x9D001134
9D001124  00000000   NOP
323:                         return(GDGL_OUTOFRANGE); // return Out of Range error 
9D001128  2402000B   ADDIU V0, ZERO, 11
9D00112C  0B4004B1   J 0x9D0012C4
9D001130  00000000   NOP
324:                     letter-=0x20;                // subtract unused ASCII characters so variable  
9D001134  93C20038   LBU V0, 56(S8)
9D001138  2442FFE0   ADDIU V0, V0, -32
9D00113C  A3C20038   SB V0, 56(S8)
325:                                                  // 'letter' can be used for an arrays value
326:                     
327:                     for(x=x0;x<(5*tsize)+x0;x+=tsize){           // Please don't try to understand this - just accept it. 
9D001140  8FC20030   LW V0, 48(S8)
9D001144  AFC20010   SW V0, 16(S8)
9D001148  0B4004A6   J 0x9D001298
9D00114C  00000000   NOP
9D001288  8F828010   LW V0, -32752(GP)
9D00128C  8FC30010   LW V1, 16(S8)
9D001290  00621021   ADDU V0, V1, V0
9D001294  AFC20010   SW V0, 16(S8)
9D001298  8F838010   LW V1, -32752(GP)
9D00129C  00601021   ADDU V0, V1, ZERO
9D0012A0  00021080   SLL V0, V0, 2
9D0012A4  00431821   ADDU V1, V0, V1
9D0012A8  8FC20030   LW V0, 48(S8)
9D0012AC  00621821   ADDU V1, V1, V0
9D0012B0  8FC20010   LW V0, 16(S8)
9D0012B4  0043102A   SLT V0, V0, V1
9D0012B8  1440FFA5   BNE V0, ZERO, 0x9D001150
9D0012BC  00000000   NOP
328:                         mask=1;                                  // reset mask variable 
9D001150  24020001   ADDIU V0, ZERO, 1
9D001154  A3C20020   SB V0, 32(S8)
329:                         for(y=y0;y<(8*tsize)+y0;y=y+tsize){      //
9D001158  8FC20034   LW V0, 52(S8)
9D00115C  AFC20014   SW V0, 20(S8)
9D001160  0B40049A   J 0x9D001268
9D001164  00000000   NOP
9D001258  8F828010   LW V0, -32752(GP)
9D00125C  8FC30014   LW V1, 20(S8)
9D001260  00621021   ADDU V0, V1, V0
9D001264  AFC20014   SW V0, 20(S8)
9D001268  8F828010   LW V0, -32752(GP)
9D00126C  000218C0   SLL V1, V0, 3
9D001270  8FC20034   LW V0, 52(S8)
9D001274  00621821   ADDU V1, V1, V0
9D001278  8FC20014   LW V0, 20(S8)
9D00127C  0043102A   SLT V0, V0, V1
9D001280  1440FFB9   BNE V0, ZERO, 0x9D001168
9D001284  00000000   NOP
330:                             for(xSize=0;xSize<tsize;xSize++)     // 
9D001168  AFC0001C   SW ZERO, 28(S8)
9D00116C  0B40048E   J 0x9D001238
9D001170  00000000   NOP
9D00122C  8FC2001C   LW V0, 28(S8)
9D001230  24420001   ADDIU V0, V0, 1
9D001234  AFC2001C   SW V0, 28(S8)
9D001238  8F828010   LW V0, -32752(GP)
9D00123C  8FC3001C   LW V1, 28(S8)
9D001240  0062102A   SLT V0, V1, V0
9D001244  1440FFCB   BNE V0, ZERO, 0x9D001174
9D001248  00000000   NOP
331:                                 for(ySize=0;ySize<tsize;ySize++) // 
9D001174  AFC00018   SW ZERO, 24(S8)
9D001178  0B400486   J 0x9D001218
9D00117C  00000000   NOP
9D00120C  8FC20018   LW V0, 24(S8)
9D001210  24420001   ADDIU V0, V0, 1
9D001214  AFC20018   SW V0, 24(S8)
9D001218  8F828010   LW V0, -32752(GP)
9D00121C  8FC30018   LW V1, 24(S8)
9D001220  0062102A   SLT V0, V1, V0
9D001224  1440FFD6   BNE V0, ZERO, 0x9D001180
9D001228  00000000   NOP
332:                                     PlotPoint(x+xSize,y+ySize,((Dfont[letter][((x-x0)/tsize)] & mask) ? color:backcolor));
9D001180  8FC30010   LW V1, 16(S8)
9D001184  8FC2001C   LW V0, 28(S8)
9D001188  00622021   ADDU A0, V1, V0
9D00118C  8FC30014   LW V1, 20(S8)
9D001190  8FC20018   LW V0, 24(S8)
9D001194  00622821   ADDU A1, V1, V0
9D001198  93C30038   LBU V1, 56(S8)
9D00119C  8FC60010   LW A2, 16(S8)
9D0011A0  8FC20030   LW V0, 48(S8)
9D0011A4  00C23023   SUBU A2, A2, V0
9D0011A8  8F828010   LW V0, -32752(GP)
9D0011AC  00C2001A   DIV A2, V0
9D0011B0  004001F4   TEQ V0, ZERO
9D0011B4  00001010   MFHI V0
9D0011B8  00003812   MFLO A3
9D0011BC  3C069D00   LUI A2, -25344
9D0011C0  00601021   ADDU V0, V1, ZERO
9D0011C4  00021080   SLL V0, V0, 2
9D0011C8  00431021   ADDU V0, V0, V1
9D0011CC  00471821   ADDU V1, V0, A3
9D0011D0  24C21BF0   ADDIU V0, A2, 7152
9D0011D4  00621021   ADDU V0, V1, V0
9D0011D8  90430000   LBU V1, 0(V0)
9D0011DC  93C20020   LBU V0, 32(S8)
9D0011E0  00621024   AND V0, V1, V0
9D0011E4  304200FF   ANDI V0, V0, 255
9D0011E8  10400004   BEQ V0, ZERO, 0x9D0011FC
9D0011EC  00000000   NOP
9D0011F0  8FC2003C   LW V0, 60(S8)
9D0011F4  0B400480   J 0x9D001200
9D0011F8  00000000   NOP
9D0011FC  8FC20040   LW V0, 64(S8)
9D001200  00403021   ADDU A2, V0, ZERO
9D001204  0F4006F1   JAL PlotPoint
9D001208  00000000   NOP
333:                             mask<<=1;                            // shift the mask left 1 bit
9D00124C  93C20020   LBU V0, 32(S8)
9D001250  00021040   SLL V0, V0, 1
9D001254  A3C20020   SB V0, 32(S8)
334:                         }
335:                     }
336:                     return(GDGL_SUCCESS);
9D0012C0  2402000A   ADDIU V0, ZERO, 10
337:                 }
9D0012C4  03C0E821   ADDU SP, S8, ZERO
9D0012C8  8FBF002C   LW RA, 44(SP)
9D0012CC  8FBE0028   LW S8, 40(SP)
9D0012D0  27BD0030   ADDIU SP, SP, 48
9D0012D4  03E00008   JR RA
9D0012D8  00000000   NOP
338:                 /************************************************
339:                  * WriteChar Function - function plots a string *
340:                  ************************************************/
341:                 int WriteString(int x0, int y0, char *string, int color, int backcolor){
9D0012DC  27BDFFD8   ADDIU SP, SP, -40
9D0012E0  AFBF0024   SW RA, 36(SP)
9D0012E4  AFBE0020   SW S8, 32(SP)
9D0012E8  03A0F021   ADDU S8, SP, ZERO
9D0012EC  AFC40028   SW A0, 40(S8)
9D0012F0  AFC5002C   SW A1, 44(S8)
9D0012F4  AFC60030   SW A2, 48(S8)
9D0012F8  AFC70034   SW A3, 52(S8)
342:                     int error_code=0;
9D0012FC  AFC00018   SW ZERO, 24(S8)
343:                     
344:                     while(*string) // will loop until NULL is reached (0x00)
9D001300  0B40052D   J 0x9D0014B4
9D001304  00000000   NOP
9D0014B4  8FC20030   LW V0, 48(S8)
9D0014B8  80420000   LB V0, 0(V0)
9D0014BC  1440FF92   BNE V0, ZERO, 0x9D001308
9D0014C0  00000000   NOP
345:                     {
346:                         error_code=WriteChar(x0, y0, *string, color, backcolor); // write the current character to the screen
9D001308  8FC20030   LW V0, 48(S8)
9D00130C  80420000   LB V0, 0(V0)
9D001310  304200FF   ANDI V0, V0, 255
9D001314  8FC30038   LW V1, 56(S8)
9D001318  AFA30010   SW V1, 16(SP)
9D00131C  8FC40028   LW A0, 40(S8)
9D001320  8FC5002C   LW A1, 44(S8)
9D001324  00403021   ADDU A2, V0, ZERO
9D001328  8FC70034   LW A3, 52(S8)
9D00132C  0F400439   JAL WriteChar
9D001330  00000000   NOP
9D001334  AFC20018   SW V0, 24(S8)
347:                         
348:                         if(error_code!=GDGL_SUCCESS) // if WriteChar returns an error 
9D001338  8FC30018   LW V1, 24(S8)
9D00133C  2402000A   ADDIU V0, ZERO, 10
9D001340  10620004   BEQ V1, V0, 0x9D001354
9D001344  00000000   NOP
349:                             return(error_code);      // stop and return it to the user 
9D001348  8FC20018   LW V0, 24(S8)
9D00134C  0B400532   J 0x9D0014C8
9D001350  00000000   NOP
350:                         
351:                         if(txwrap) {                         // if the user wants the text to wrap:
9D001354  83828014   LB V0, -32748(GP)
9D001358  1040003F   BEQ V0, ZERO, 0x9D001458
9D00135C  00000000   NOP
352:                             if(Scrn_W-(x0+5*tsize)<5*tsize){ // if there is not enough room to print the character on the same line
9D001360  8F838010   LW V1, -32752(GP)
9D001364  00601021   ADDU V0, V1, ZERO
9D001368  00021080   SLL V0, V0, 2
9D00136C  00431021   ADDU V0, V0, V1
9D001370  00021023   SUBU V0, ZERO, V0
9D001374  8FC30028   LW V1, 40(S8)
9D001378  00431023   SUBU V0, V0, V1
9D00137C  24440080   ADDIU A0, V0, 128
9D001380  8F838010   LW V1, -32752(GP)
9D001384  00601021   ADDU V0, V1, ZERO
9D001388  00021080   SLL V0, V0, 2
9D00138C  00431021   ADDU V0, V0, V1
9D001390  0082102A   SLT V0, A0, V0
9D001394  10400017   BEQ V0, ZERO, 0x9D0013F4
9D001398  00000000   NOP
353:                                 y0+=8*tsize;                 // drop the current line down one 
9D00139C  8F828010   LW V0, -32752(GP)
9D0013A0  000210C0   SLL V0, V0, 3
9D0013A4  8FC3002C   LW V1, 44(S8)
9D0013A8  00621021   ADDU V0, V1, V0
9D0013AC  AFC2002C   SW V0, 44(S8)
354:                                 if(Scrn_H-y0<8*tsize)        // if there's not enough room to print the character on the next line
9D0013B0  24030080   ADDIU V1, ZERO, 128
9D0013B4  8FC2002C   LW V0, 44(S8)
9D0013B8  00621823   SUBU V1, V1, V0
9D0013BC  8F828010   LW V0, -32752(GP)
9D0013C0  000210C0   SLL V0, V0, 3
9D0013C4  0062102A   SLT V0, V1, V0
9D0013C8  10400004   BEQ V0, ZERO, 0x9D0013DC
9D0013CC  00000000   NOP
355:                                     return(GDGL_PRNTCUTOFF); // return error
9D0013D0  2402000C   ADDIU V0, ZERO, 12
9D0013D4  0B400532   J 0x9D0014C8
9D0013D8  00000000   NOP
356:                                 x0=0;                        // reset x axis
9D0013DC  AFC00028   SW ZERO, 40(S8)
357:                                 string++;                    // increment the current character
9D0013E0  8FC20030   LW V0, 48(S8)
9D0013E4  24420001   ADDIU V0, V0, 1
9D0013E8  AFC20030   SW V0, 48(S8)
9D0013EC  0B40052D   J 0x9D0014B4
9D0013F0  00000000   NOP
358:                             }
359:                             else {                                  // else 
360:                                 x0+=5*tsize;                        // do the regular text stuff
9D0013F4  8F838010   LW V1, -32752(GP)
9D0013F8  00601021   ADDU V0, V1, ZERO
9D0013FC  00021080   SLL V0, V0, 2
9D001400  00431021   ADDU V0, V0, V1
9D001404  8FC30028   LW V1, 40(S8)
9D001408  00621021   ADDU V0, V1, V0
9D00140C  AFC20028   SW V0, 40(S8)
361:                                 PlotVLine(x0,y0,7*tsize,backcolor); //
9D001410  8F838010   LW V1, -32752(GP)
9D001414  00601021   ADDU V0, V1, ZERO
9D001418  000210C0   SLL V0, V0, 3
9D00141C  00431023   SUBU V0, V0, V1
9D001420  8FC40028   LW A0, 40(S8)
9D001424  8FC5002C   LW A1, 44(S8)
9D001428  00403021   ADDU A2, V0, ZERO
9D00142C  8FC70038   LW A3, 56(S8)
9D001430  0F400065   JAL PlotVLine
9D001434  00000000   NOP
362:                                 string++;                           //
9D001438  8FC20030   LW V0, 48(S8)
9D00143C  24420001   ADDIU V0, V0, 1
9D001440  AFC20030   SW V0, 48(S8)
363:                                 x0++;                               //
9D001444  8FC20028   LW V0, 40(S8)
9D001448  24420001   ADDIU V0, V0, 1
9D00144C  AFC20028   SW V0, 40(S8)
9D001450  0B40052D   J 0x9D0014B4
9D001454  00000000   NOP
364:                             }
365:                         }
366:                         else {                                 // else if the user does not want the text to wrap:
367:                             x0+=5*tsize;                       // increment the x axis to make a spot for the new character
9D001458  8F838010   LW V1, -32752(GP)
9D00145C  00601021   ADDU V0, V1, ZERO
9D001460  00021080   SLL V0, V0, 2
9D001464  00431021   ADDU V0, V0, V1
9D001468  8FC30028   LW V1, 40(S8)
9D00146C  00621021   ADDU V0, V1, V0
9D001470  AFC20028   SW V0, 40(S8)
368:                             PlotVLine(x0,y0,7*tsize,backcolor);// plot a blank line between characters
9D001474  8F838010   LW V1, -32752(GP)
9D001478  00601021   ADDU V0, V1, ZERO
9D00147C  000210C0   SLL V0, V0, 3
9D001480  00431023   SUBU V0, V0, V1
9D001484  8FC40028   LW A0, 40(S8)
9D001488  8FC5002C   LW A1, 44(S8)
9D00148C  00403021   ADDU A2, V0, ZERO
9D001490  8FC70038   LW A3, 56(S8)
9D001494  0F400065   JAL PlotVLine
9D001498  00000000   NOP
369:                             string++;                          // increment the current character
9D00149C  8FC20030   LW V0, 48(S8)
9D0014A0  24420001   ADDIU V0, V0, 1
9D0014A4  AFC20030   SW V0, 48(S8)
370:                             x0++;                              // increment x axis to make room for line just plotted
9D0014A8  8FC20028   LW V0, 40(S8)
9D0014AC  24420001   ADDIU V0, V0, 1
9D0014B0  AFC20028   SW V0, 40(S8)
371:                         }
372:                     }
373:                     return(GDGL_SUCCESS); // return success code 
9D0014C4  2402000A   ADDIU V0, ZERO, 10
374:                 }
9D0014C8  03C0E821   ADDU SP, S8, ZERO
9D0014CC  8FBF0024   LW RA, 36(SP)
9D0014D0  8FBE0020   LW S8, 32(SP)
9D0014D4  27BD0028   ADDIU SP, SP, 40
9D0014D8  03E00008   JR RA
9D0014DC  00000000   NOP
375:                 /************************************************
376:                  * SetTextSize Function - sets the current      *
377:                  * text size.                                   *
378:                  ************************************************/
379:                 int SetTextSize(int Tx_size){
9D0014E0  27BDFFF8   ADDIU SP, SP, -8
9D0014E4  AFBE0004   SW S8, 4(SP)
9D0014E8  03A0F021   ADDU S8, SP, ZERO
9D0014EC  AFC40008   SW A0, 8(S8)
380:                     if(Tx_size==0)               // if size is zero
9D0014F0  8FC20008   LW V0, 8(S8)
9D0014F4  14400004   BNE V0, ZERO, 0x9D001508
9D0014F8  00000000   NOP
381:                         return(GDGL_OUTOFRANGE); // return error 
9D0014FC  2402000B   ADDIU V0, ZERO, 11
9D001500  0B400545   J 0x9D001514
9D001504  00000000   NOP
382:                     tsize=Tx_size;               // else set global size variable to Tx_size
9D001508  8FC20008   LW V0, 8(S8)
9D00150C  AF828010   SW V0, -32752(GP)
383:                     return(GDGL_SUCCESS);        // return success 
9D001510  2402000A   ADDIU V0, ZERO, 10
384:                 }
9D001514  03C0E821   ADDU SP, S8, ZERO
9D001518  8FBE0004   LW S8, 4(SP)
9D00151C  27BD0008   ADDIU SP, SP, 8
9D001520  03E00008   JR RA
9D001524  00000000   NOP
385:                 /************************************************
386:                  * SetTextWrap Function - sets the text to wrap *  
387:                  * or not.                                      *
388:                  ************************************************/
389:                 void SetTextWrap(char Tx_wrap){
9D001528  27BDFFF8   ADDIU SP, SP, -8
9D00152C  AFBE0004   SW S8, 4(SP)
9D001530  03A0F021   ADDU S8, SP, ZERO
9D001534  00801021   ADDU V0, A0, ZERO
9D001538  A3C20008   SB V0, 8(S8)
390:                     if(Tx_wrap)   // if Tx_wrap is 1
9D00153C  83C20008   LB V0, 8(S8)
9D001540  10400005   BEQ V0, ZERO, 0x9D001558
9D001544  00000000   NOP
391:                         txwrap=1; // set the text to wrap
9D001548  24020001   ADDIU V0, ZERO, 1
9D00154C  A3828014   SB V0, -32748(GP)
9D001550  0B400557   J 0x9D00155C
9D001554  00000000   NOP
392:                     else          // else
393:                         txwrap=0; // set it to not wrap
9D001558  A3808014   SB ZERO, -32748(GP)
394:                 }
9D00155C  03C0E821   ADDU SP, S8, ZERO
9D001560  8FBE0004   LW S8, 4(SP)
9D001564  27BD0008   ADDIU SP, SP, 8
9D001568  03E00008   JR RA
9D00156C  00000000   NOP
395:                 /*******************************************************************************
396:                  * Bitmap functions past this point                                            *
397:                  *******************************************************************************/
398:                 /************************************************
399:                  * PlotBitmap Function - plots a R5 G6 B5       *  
400:                  * bitmap.                                      *
401:                  ************************************************/
402:                 void PlotBitmap(int x0, int y0, int w, int h,const unsigned short *image){
9D001570  27BDFFE0   ADDIU SP, SP, -32
9D001574  AFBF001C   SW RA, 28(SP)
9D001578  AFBE0018   SW S8, 24(SP)
9D00157C  03A0F021   ADDU S8, SP, ZERO
9D001580  AFC40020   SW A0, 32(S8)
9D001584  AFC50024   SW A1, 36(S8)
9D001588  AFC60028   SW A2, 40(S8)
9D00158C  AFC7002C   SW A3, 44(S8)
403:                     int x,y;
404:                     for(y=0;y<h;y++)
9D001590  AFC00014   SW ZERO, 20(S8)
9D001594  0B400589   J 0x9D001624
9D001598  00000000   NOP
9D001618  8FC20014   LW V0, 20(S8)
9D00161C  24420001   ADDIU V0, V0, 1
9D001620  AFC20014   SW V0, 20(S8)
9D001624  8FC30014   LW V1, 20(S8)
9D001628  8FC2002C   LW V0, 44(S8)
9D00162C  0062102A   SLT V0, V1, V0
9D001630  1440FFDA   BNE V0, ZERO, 0x9D00159C
9D001634  00000000   NOP
405:                         for(x=0;x<w;x++)
9D00159C  AFC00010   SW ZERO, 16(S8)
9D0015A0  0B400581   J 0x9D001604
9D0015A4  00000000   NOP
9D0015F8  8FC20010   LW V0, 16(S8)
9D0015FC  24420001   ADDIU V0, V0, 1
9D001600  AFC20010   SW V0, 16(S8)
9D001604  8FC30010   LW V1, 16(S8)
9D001608  8FC20028   LW V0, 40(S8)
9D00160C  0062102A   SLT V0, V1, V0
9D001610  1440FFE5   BNE V0, ZERO, 0x9D0015A8
9D001614  00000000   NOP
406:                             PlotPoint(x+x0,y+y0,*(image+(x+y*w)));    
9D0015A8  8FC30010   LW V1, 16(S8)
9D0015AC  8FC20020   LW V0, 32(S8)
9D0015B0  00622021   ADDU A0, V1, V0
9D0015B4  8FC30014   LW V1, 20(S8)
9D0015B8  8FC20024   LW V0, 36(S8)
9D0015BC  00621821   ADDU V1, V1, V0
9D0015C0  8FC50014   LW A1, 20(S8)
9D0015C4  8FC20028   LW V0, 40(S8)
9D0015C8  00A20018   MULT 0, A1, V0
9D0015CC  8FC20010   LW V0, 16(S8)
9D0015D0  00002812   MFLO A1
9D0015D4  00A21021   ADDU V0, A1, V0
9D0015D8  00021040   SLL V0, V0, 1
9D0015DC  8FC50030   LW A1, 48(S8)
9D0015E0  00A21021   ADDU V0, A1, V0
9D0015E4  94420000   LHU V0, 0(V0)
9D0015E8  00602821   ADDU A1, V1, ZERO
9D0015EC  00403021   ADDU A2, V0, ZERO
9D0015F0  0F4006F1   JAL PlotPoint
9D0015F4  00000000   NOP
407:                 }
9D001638  03C0E821   ADDU SP, S8, ZERO
9D00163C  8FBF001C   LW RA, 28(SP)
9D001640  8FBE0018   LW S8, 24(SP)
9D001644  27BD0020   ADDIU SP, SP, 32
9D001648  03E00008   JR RA
9D00164C  00000000   NOP
408:                 
409:                 int GDGL_abs(int num) {
9D001650  27BDFFF8   ADDIU SP, SP, -8
9D001654  AFBE0004   SW S8, 4(SP)
9D001658  03A0F021   ADDU S8, SP, ZERO
9D00165C  AFC40008   SW A0, 8(S8)
410:                   if(num<0)         // if the number is negative 
9D001660  8FC20008   LW V0, 8(S8)
9D001664  04410005   BGEZ V0, 0x9D00167C
9D001668  00000000   NOP
411:                     return(-num);   //  return it's positive 
9D00166C  8FC20008   LW V0, 8(S8)
9D001670  00021023   SUBU V0, ZERO, V0
9D001674  0B4005A0   J 0x9D001680
9D001678  00000000   NOP
412:                   else              // else 
413:                     return(num);    //  return the number 
9D00167C  8FC20008   LW V0, 8(S8)
414:                 }
9D001680  03C0E821   ADDU SP, S8, ZERO
9D001684  8FBE0004   LW S8, 4(SP)
9D001688  27BD0008   ADDIU SP, SP, 8
9D00168C  03E00008   JR RA
9D001690  00000000   NOP
415:                 /*********************************************************************************
416:                  * REASOURCES:                                                                   *
417:                  * http://web.engr.oregonstate.edu/~sllu/bcircle.pdf - circle drawing algorithm  *
418:                  * https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm
419:                  * https://github.com/jorticus/zeitgeber-firmware
420:                  *********************************************************************************/
421:                 
---  c:/program files (x86)/microchip/xc32/v1.42/pic32mx/include/lega-c/peripheral/system.h  ------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
9D0016C0  8FC20018   LW V0, 24(S8)
9D0016C4  AFC2001C   SW V0, 28(S8)
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D0016C8  8FC30018   LW V1, 24(S8)
9D0016CC  3C0204C4   LUI V0, 1220
9D0016D0  3442B401   ORI V0, V0, -19455
9D0016D4  0062102B   SLTU V0, V1, V0
9D0016D8  14400008   BNE V0, ZERO, 0x9D0016FC
9D0016DC  00000000   NOP
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
9D0016E0  3C020008   LUI V0, 8
9D0016E4  AFC20020   SW V0, 32(S8)
131:                         pb_clock >>= 1;
9D0016E8  8FC2001C   LW V0, 28(S8)
9D0016EC  00021042   SRL V0, V0, 1
9D0016F0  AFC2001C   SW V0, 28(S8)
9D0016F4  0B4005C0   J 0x9D001700
9D0016F8  00000000   NOP
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
9D0016FC  AFC00020   SW ZERO, 32(S8)
9D001700  8FC20020   LW V0, 32(S8)
9D001704  AFC20024   SW V0, 36(S8)
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
9D001848  8FC2001C   LW V0, 28(S8)
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
9D00184C  AFC2003C   SW V0, 60(S8)
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
9D001850  AFC00040   SW ZERO, 64(S8)
9D001854  0B40061F   J 0x9D00187C
9D001858  00000000   NOP
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
9D00187C  8FC30014   LW V1, 20(S8)
9D001880  3C0201C9   LUI V0, 457
9D001884  3442C381   ORI V0, V0, -15487
9D001888  0062102B   SLTU V0, V1, V0
9D00188C  1040FFF3   BEQ V0, ZERO, 0x9D00185C
9D001890  00000000   NOP
240:                     {
241:                         wait_states++;
9D00185C  8FC20040   LW V0, 64(S8)
9D001860  24420001   ADDIU V0, V0, 1
9D001864  AFC20040   SW V0, 64(S8)
242:                         sys_clock -= FLASH_SPEED_HZ;
9D001868  8FC30014   LW V1, 20(S8)
9D00186C  3C02FE36   LUI V0, -458
9D001870  34423C80   ORI V0, V0, 15488
9D001874  00621021   ADDU V0, V1, V0
9D001878  AFC20014   SW V0, 20(S8)
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
9D001894  0F40085B   JAL INTDisableInterrupts
9D001898  00000000   NOP
9D00189C  AFC20044   SW V0, 68(S8)
246:                     mCheConfigure(wait_states);
9D0018A0  3C02BF88   LUI V0, -16504
9D0018A4  8FC30040   LW V1, 64(S8)
9D0018A8  AC434000   SW V1, 16384(V0)
247:                     INTRestoreInterrupts(int_status);
9D0018AC  8FC40044   LW A0, 68(S8)
9D0018B0  0F400842   JAL INTRestoreInterrupts
9D0018B4  00000000   NOP
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
9D0018B8  8FC2003C   LW V0, 60(S8)
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
9D0018BC  AFC20048   SW V0, 72(S8)
292:                 
293:                     int_status=INTDisableInterrupts();
9D0018C0  0F40085B   JAL INTDisableInterrupts
9D0018C4  00000000   NOP
9D0018C8  AFC2004C   SW V0, 76(S8)
294:                 
295:                     mBMXDisableDRMWaitState();
9D0018CC  3C02BF88   LUI V0, -16504
9D0018D0  24030040   ADDIU V1, ZERO, 64
9D0018D4  AC432004   SW V1, 8196(V0)
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
9D0018D8  3C02BF88   LUI V0, -16504
9D0018DC  8C424000   LW V0, 16384(V0)
9D0018E0  AFC20050   SW V0, 80(S8)
299:                     cache_status |= CHE_CONF_PF_ALL;
9D0018E4  8FC20050   LW V0, 80(S8)
9D0018E8  34420030   ORI V0, V0, 48
9D0018EC  AFC20050   SW V0, 80(S8)
300:                     mCheConfigure(cache_status);
9D0018F0  3C02BF88   LUI V0, -16504
9D0018F4  8FC30050   LW V1, 80(S8)
9D0018F8  AC434000   SW V1, 16384(V0)
301:                     CheKseg0CacheOn();
9D0018FC  0F40084F   JAL CheKseg0CacheOn
9D001900  00000000   NOP
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
9D001904  8FC4004C   LW A0, 76(S8)
9D001908  0F400842   JAL INTRestoreInterrupts
9D00190C  00000000   NOP
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
355:                 
356:                     mBMXDisableDRMWaitState();
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
381:                 
382:                     INTRestoreInterrupts(int_status);
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  c:/program files (x86)/microchip/xc32/v1.42/pic32mx/include/lega-c/peripheral/osc.h  ---------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                   // Reference Oscillator Source Select bits - values are mutually exclusive
169:                   #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                   #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                   #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                   #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                   #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                   #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                   #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                   #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                   #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                   typedef enum
180:                   {
181:                       OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                       OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                       OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                       OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                   } OSCREFConfigFlags;
186:                 
187:                   void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                   #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
190:                 
191:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
192:                 
193:                 #undef  NEED_OSCREFCONFIG_FLAGS
194:                 
195:                 
196:                 /*********************************************************************
197:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
198:                  *
199:                  * Description: Configures peripheral bus divisor
200:                  *
201:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
202:                  *
203:                  * Inputs:    oscPbDiv - desired PB divider
204:                  *
205:                  * Output:      None
206:                  *
207:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
208:                  *
209:                  ********************************************************************/
210:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
211:                 {
212:                     unsigned int dma_status;
213:                     unsigned int int_status;
214:                     __OSCCONbits_t oscBits;
215:                 
216:                     mSYSTEMUnlock(int_status, dma_status);
9D001708  0F40085B   JAL INTDisableInterrupts
9D00170C  00000000   NOP
9D001710  AFC20028   SW V0, 40(S8)
9D001758  AFC20030   SW V0, 48(S8)
9D00175C  3C02BF81   LUI V0, -16511
9D001760  AC40F230   SW ZERO, -3536(V0)
9D001764  3C02BF81   LUI V0, -16511
9D001768  3C03AA99   LUI V1, -21863
9D00176C  34636655   ORI V1, V1, 26197
9D001770  AC43F230   SW V1, -3536(V0)
9D001774  3C02BF81   LUI V0, -16511
9D001778  3C035566   LUI V1, 21862
9D00177C  346399AA   ORI V1, V1, -26198
9D001780  AC43F230   SW V1, -3536(V0)
217:                 
218:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
9D001784  3C02BF81   LUI V0, -16511
9D001788  8C42F000   LW V0, -4096(V0)
9D00178C  AFC20054   SW V0, 84(S8)
219:                     oscBits.PBDIV=0;
9D001790  8FC20054   LW V0, 84(S8)
9D001794  7C02A4C4   INS V0, ZERO, 19, 2
9D001798  AFC20054   SW V0, 84(S8)
220:                     oscBits.w|=oscPbDiv;
9D00179C  8FC30054   LW V1, 84(S8)
9D0017A0  8FC20024   LW V0, 36(S8)
9D0017A4  00621025   OR V0, V1, V0
9D0017A8  AFC20054   SW V0, 84(S8)
221:                     OSCCON=oscBits.w;       // write back
9D0017AC  8FC30054   LW V1, 84(S8)
9D0017B0  3C02BF81   LUI V0, -16511
9D0017B4  AC43F000   SW V1, -4096(V0)
222:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
9D0017B8  3C02BF81   LUI V0, -16511
9D0017BC  8C42F000   LW V0, -4096(V0)
9D0017C0  AFC20054   SW V0, 84(S8)
223:                 
224:                     mSYSTEMLock(int_status, dma_status);
9D0017C4  3C02BF81   LUI V0, -16511
9D0017C8  3C033333   LUI V1, 13107
9D0017CC  34633333   ORI V1, V1, 13107
9D0017D0  AC43F230   SW V1, -3536(V0)
9D0017D4  8FC20030   LW V0, 48(S8)
9D0017D8  AFC20034   SW V0, 52(S8)
9D00183C  8FC40028   LW A0, 40(S8)
9D001840  0F400842   JAL INTRestoreInterrupts
9D001844  00000000   NOP
225:                 }
226:                 
227:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
228:                 
229:                 
230:                 
231:                     /******************************************************************************
232:                      * Available options for config parameter
233:                      *****************************************************************************/
234:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
235:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
236:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
239:                     /***********************************
240:                      * End config parameter values
241:                      ************************************/
242:                 
243:                 
244:                 /*********************************************************************
245:                  * Function:    mOSCGetPBDIV()
246:                  *
247:                  * Description: Reads peripheral bus divisor
248:                  *
249:                  * PreCondition:None
250:                  *
251:                  * Inputs:      None
252:                  *
253:                  * Output:      None
254:                  *
255:                  * Example:     mOSCGetPBDIV()
256:                  *
257:                  ********************************************************************/
258:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
259:                 
260:                 
261:                 /*********************************************************************
262:                  * Function:    mOSCClockFailStatus()
263:                  *
264:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
265:                  *
266:                  * PreCondition: None
267:                  *
268:                  * Inputs:      None
269:                  *
270:                  * Output:      None
271:                  *
272:                  * Example:     mOSCClockFailStatus()
273:                  *
274:                  ********************************************************************/
275:                 #define mOSCClockFailStatus (OSCCONbits.CF)
276:                 
277:                 
278:                 /*********************************************************************
279:                  * Function:        mOSCEnableSOSC()
280:                  *
281:                  * Description:     Enables the LPRC
282:                  *
283:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
284:                  *
285:                  * Inputs:          None
286:                  *
287:                  * Output:          None
288:                  *
289:                  * Example:         mOSCEnableSOSC()
290:                  *
291:                  ********************************************************************/
292:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
293:                 
294:                 
295:                 /*********************************************************************
296:                  * Function:        mOSCDisableSOSC(config)
297:                  *
298:                  * Description:     Disables SOSC
299:                  *
300:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
301:                  *
302:                  * Inputs:          None
303:                  *
304:                  * Output:          None
305:                  *
306:                  * Example:         mOSCDisableSOSC()
307:                  *
308:                  ********************************************************************/
309:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
310:                 
311:                 
312:                 
313:                 #endif
---  c:/program files (x86)/microchip/xc32/v1.42/pic32mx/include/lega-c/peripheral/dma_1xx_2xx.h  -------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_1XX_2XX_H_
43:                  #define _DMA_1XX_2XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                      #define _DMA_CHANNELS       // DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                      typedef enum
66:                      {
67:                          DMA_CHANNEL0,
68:                      #ifdef _DMAC1
69:                          DMA_CHANNEL1,
70:                      # ifdef _DMAC2
71:                          DMA_CHANNEL2,
72:                      #  ifdef _DMAC3
73:                          DMA_CHANNEL3,
74:                      #  endif// _DMAC3
75:                      # endif // _DMAC2
76:                      #endif  // _DMAC1
77:                          //  add/remove DMA channel as needed here
78:                  
79:                          DMA_CHANNELS    // number of current available channels
80:                      }DmaChannel;
81:                  
82:                  
83:                      // Relative Dma channels priority, between each other
84:                      typedef enum
85:                      {
86:                          DMA_CHN_PRI0,
87:                          DMA_CHN_PRI1,
88:                          DMA_CHN_PRI2,
89:                          DMA_CHN_PRI3
90:                      }DmaChannelPri;
91:                  
92:                  
93:                  
94:                      // high level definitions for the API functions
95:                  
96:                      typedef enum
97:                      {
98:                          DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
99:                          DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
100:                         DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
101:                         DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
102:                         DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
103:                         DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
104:                         DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
105:                     }DmaOpenFlags;  // flags for the channel open
106:                 
107:                 
108:                     typedef enum
109:                     {
110:                         DMA_EV_ERR =            0x1,        // address error event
111:                         DMA_EV_ABORT =          0x2,        // transfer abort event
112:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
113:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
114:                         DMA_EV_DST_HALF =       0x10,       // destination half event
115:                         DMA_EV_DST_FULL =       0x20,       // destination full event
116:                         DMA_EV_SRC_HALF =       0x40,       // source half event
117:                         DMA_EV_SRC_FULL =       0x80,       // source full event
118:                 
119:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
120:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
121:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
122:                 
123:                 
124:                     typedef enum
125:                     {
126:                         DMA_TXFER_OK,           // the transfer was performed successfully
127:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
128:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
129:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
130:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
131:                         DMA_TXFER_TMO           // DMA transfer timeout
132:                     }DmaTxferRes;       // DMA transfer result
133:                 
134:                     typedef enum
135:                     {
136:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
137:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
138:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
139:                     }DmaWaitMode;       // DMA transfer wait mode
140:                 
141:                     typedef enum
142:                     {
143:                         DMA_CHKSUM_CRC,     // LFSR CRC
144:                         DMA_CHKSUM_IP,      // IP Checksum
145:                     }DmaChksumType;     // DMA SFM supported checksum types
146:                 
147:                     typedef enum
148:                     {
149:                         DMA_BITO_MSb,       // MSb first (not reflected)
150:                         DMA_BITO_LSb,       // LSb first (reflected)
151:                     }DmaBitOrder;       // DMA SFM supported bit ordering
152:                 
153:                     typedef enum
154:                     {
155:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
156:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
157:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
158:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
159:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
160:                 
161:                 
162:                     /*********************************************************************
163:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
164:                      *
165:                      * PreCondition:    chPri  - valid channel priority, 0-3
166:                      *
167:                      * Input:           chn    - channel to be configured in the DMA controller
168:                      *                  chPri  - the priority given to the channel, 0-3
169:                      *                  oFlags - orred flags specifying the open mode:
170:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
171:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
172:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
173:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
174:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
175:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
176:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
177:                      *
178:                      *
179:                      *
180:                      * Output:          None
181:                      *
182:                      * Side Effects:    None
183:                      *
184:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
185:                      *
186:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
187:                      *                  Use the low level functions to address special settings.
188:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
189:                      *                  After that the channel is configured.
190:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
191:                      *                  if DMA_OPEN_ENABLE flag was not specified.
192:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
193:                      *                  This way, the transfer will occur correctly together with CRC calculation.
194:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
195:                      *                  User has to call event channel functions to enable the event flags if needed.
196:                      *
197:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
198:                      ********************************************************************/
199:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
200:                 
201:                     /*********************************************************************
202:                      * Function:        void DmaChnEnable(DmaChannel chn)
203:                      *
204:                      * PreCondition:    None
205:                      *
206:                      * Input:           chn     - channel to be enabled
207:                      *
208:                      * Output:          None
209:                      *
210:                      * Side Effects:    None
211:                      *
212:                      * Overview:        The function enables a previously configured DMA channel.
213:                      *
214:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
215:                      *
216:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
217:                      ********************************************************************/
218:                      void           DmaChnEnable(DmaChannel chn);
219:                 
220:                     /*********************************************************************
221:                      * Function:        void DmaChnDisable(DmaChannel chn)
222:                      *
223:                      * PreCondition:    None
224:                      *
225:                      * Input:           chn     - selected channel in the DMA controller
226:                      *
227:                      * Output:          None
228:                      *
229:                      * Side Effects:    None
230:                      *
231:                      * Overview:        The function disables a DMA channel. The channel operation stops.
232:                      *
233:                      * Note:            None.
234:                      *
235:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
236:                      ********************************************************************/
237:                      void           DmaChnDisable(DmaChannel chn);
238:                 
239:                     /*********************************************************************
240:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
241:                      *
242:                      * PreCondition:    chn     - valid DMA channel
243:                      *              - vSrcAdd, vDstAdd  - valid pointers
244:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
245:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
246:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
247:                      *
248:                      * Input:           chn         - DMA channel number
249:                      *                              - vSrcAdd: source of the DMA transfer
250:                      *                              - vDstAdd: destination of the DMA transfer
251:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
252:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
253:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
254:                      *
255:                      * Output:          None
256:                      *
257:                      * Side Effects:    None
258:                      *
259:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
260:                      *                  the source and the destination addresses.
261:                      *                  the source and destination lengths
262:                      *                  and the number of bytes transferred per event.
263:                      *
264:                      * Note:            The function clears the existing DMA channel event flags.
265:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
266:                      *
267:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
268:                      ********************************************************************/
269:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
270:                 
271:                 
272:                     /*********************************************************************
273:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
274:                      *
275:                      * PreCondition:    chn     - valid DMA channel
276:                      *
277:                      * Input:           chn     - DMA channel number
278:                      *              - vSrcAdd: source (virtual) of the DMA transfer
279:                      * Output:          None
280:                      *
281:                      * Side Effects:    None
282:                      *
283:                      * Overview:        The function is a helper to set directly the transfer source address.
284:                      *
285:                      * Note:            None.
286:                      *
287:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
288:                      ********************************************************************/
289:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
290:                 
291:                     /*********************************************************************
292:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
293:                      *
294:                      * PreCondition:    chn     - valid DMA channel
295:                      *
296:                      * Input:           chn         - DMA channel number
297:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
298:                      * Output:          None
299:                      *
300:                      * Side Effects:    None
301:                      *
302:                      * Overview:        The function is a helper to set directly the transfer destination address.
303:                      *
304:                      * Note:            None
305:                      *
306:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
307:                      ********************************************************************/
308:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
309:                 
310:                     /*********************************************************************
311:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
312:                      *
313:                      * PreCondition:    chn - valid DMA channel
314:                      *
315:                      * Input:           chn     - DMA channel number
316:                      *                  pattern -  the match pattern
317:                      *
318:                      * Output:          None
319:                      *
320:                      * Side Effects:    None
321:                      *
322:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
323:                      *
324:                      * Note:            None.
325:                      *
326:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
327:                      ********************************************************************/
328:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
329:                 
330:                     /*********************************************************************
331:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
332:                      *
333:                      * PreCondition:    chn - valid DMA channel
334:                      *
335:                      * Input:           chn     - DMA channel number
336:                      *
337:                      * Output:          The channel match pattern.
338:                      *
339:                      * Side Effects:    None
340:                      *
341:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
342:                      *
343:                      * Note:            None.
344:                      *
345:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
346:                      ********************************************************************/
347:                      int            DmaChnGetMatchPattern(DmaChannel chn);
348:                 
349:                     /*********************************************************************
350:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
351:                      *
352:                      * PreCondition:    chn - valid DMA channel
353:                      *
354:                      * Input:           chn     - DMA channel number
355:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
356:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
357:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
358:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
359:                      *                              If 0, wait forever.
360:                      *
361:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
362:                      *                  an DmaTxferRes error code  otherwise
363:                      *
364:                      * Side Effects:    None
365:                      *
366:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
367:                      *                  The DMA channel is enabled.
368:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
369:                      *                  this event) the function will periodically query the DMA controller for the
370:                      *                  transfer completion status.
371:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
372:                      *                  the block transfer than the function will re-force the transfer for each cell.
373:                      *
374:                      * Note:            This function can not ne used when the DMA channel is triggerred
375:                      *                  by hardware interrupt requests.
376:                      *                  This is because the transfers are software forced, theere is no
377:                      *                  wait for the occurrence of the hardware trigger.
378:                      *
379:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
380:                      ********************************************************************/
381:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
382:                 
383:                     /*********************************************************************
384:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
385:                      *
386:                      * PreCondition:    chn - valid DMA channel
387:                      *
388:                      * Input:           chn     - DMA channel number
389:                      *
390:                      * Output:          None
391:                      *
392:                      * Side Effects:    None
393:                      *
394:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
395:                      *
396:                      * Note:            None.
397:                      *
398:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
399:                      ********************************************************************/
400:                      void           DmaChnForceTxfer(DmaChannel chn);
401:                 
402:                     /*********************************************************************
403:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
404:                      *
405:                      * PreCondition:    chn - valid DMA channel
406:                      *
407:                      * Input:           chn     - DMA channel number
408:                      *
409:                      * Output:          None
410:                      *
411:                      * Side Effects:    None
412:                      *
413:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
414:                      *
415:                      * Note:            None.
416:                      *
417:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
418:                      ********************************************************************/
419:                      void           DmaChnAbortTxfer(DmaChannel chn);
420:                 
421:                     // High level channel event and interrupt control functions
422:                 
423:                     /*********************************************************************
424:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
425:                      *
426:                      * PreCondition:    chn - valid DMA channel
427:                      *
428:                      * Input:           chn     - DMA channel number
429:                      *                  eFlags  - event flags with the following significance:
430:                      *                              - DMA_EV_ERR: address error event
431:                      *                              - DMA_EV_ABORT: transfer abort event
432:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
433:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
434:                      *                              - DMA_EV_DST_HALF: destination half event
435:                      *                              - DMA_EV_DST_FULL: destination full event
436:                      *                              - DMA_EV_SRC_HALF: source half event
437:                      *                              - DMA_EV_SRC_FULL: source full event
438:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
439:                      *
440:                      * Output:          None
441:                      *
442:                      * Side Effects:    None
443:                      *
444:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
445:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
446:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
447:                      *
448:                      * Note:            None.
449:                      *
450:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
451:                      ********************************************************************/
452:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
453:                 
454:                     /*********************************************************************
455:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
456:                      *
457:                      * PreCondition:    chn - valid DMA channel
458:                      *
459:                      * Input:           chn     - DMA channel number
460:                      *                  eFlags  - event flags with the following significance:
461:                      *                              - DMA_EV_ERR: address error event
462:                      *                              - DMA_EV_ABORT: transfer abort event
463:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
464:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
465:                      *                              - DMA_EV_DST_HALF: destination half event
466:                      *                              - DMA_EV_DST_FULL: destination full event
467:                      *                              - DMA_EV_SRC_HALF: source half event
468:                      *                              - DMA_EV_SRC_FULL: source full event
469:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
470:                      *
471:                      * Output:          None
472:                      *
473:                      * Side Effects:    None
474:                      *
475:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
476:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
477:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
478:                      *
479:                      * Note:            None.
480:                      *
481:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
482:                      ********************************************************************/
483:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
484:                 
485:                     /*********************************************************************
486:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
487:                      *
488:                      * PreCondition:    chn - valid DMA channel
489:                      *
490:                      * Input:           chn     - DMA channel number
491:                      *                  eFlags  - event flags with the following significance:
492:                      *                              - DMA_EV_ERR: address error event
493:                      *                              - DMA_EV_ABORT: transfer abort event
494:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
495:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
496:                      *                              - DMA_EV_DST_HALF: destination half event
497:                      *                              - DMA_EV_DST_FULL: destination full event
498:                      *                              - DMA_EV_SRC_HALF: source half event
499:                      *                              - DMA_EV_SRC_FULL: source full event
500:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
501:                      *
502:                      * Output:          None
503:                      *
504:                      * Side Effects:    None
505:                      *
506:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
507:                      *                  The channel event flags are forced to the eFlags value.
508:                      *
509:                      * Note:            None.
510:                      *
511:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
512:                      ********************************************************************/
513:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
514:                 
515:                     /*********************************************************************
516:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
517:                      *
518:                      * PreCondition:    chn - valid DMA channel
519:                      *
520:                      * Input:           chn     - DMA channel number
521:                      *
522:                      * Output:          - event flags with the following significance:
523:                      *                      - DMA_EV_ERR: address error event
524:                      *                      - DMA_EV_ABORT: transfer abort event
525:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
526:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
527:                      *                      - DMA_EV_DST_HALF: destination half event
528:                      *                      - DMA_EV_DST_FULL: destination full event
529:                      *                      - DMA_EV_SRC_HALF: source half event
530:                      *                      - DMA_EV_SRC_FULL: source full event
531:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
532:                      *
533:                      * Side Effects:    None
534:                      *
535:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
536:                      *
537:                      * Note:            None.
538:                      *
539:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
540:                      ********************************************************************/
541:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
542:                 
543:                     /*********************************************************************
544:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
545:                      *
546:                      * PreCondition:    chn - valid DMA channel
547:                      *
548:                      * Input:           chn     - DMA channel number
549:                      *                  eFlags  - event flags with the following significance:
550:                      *                              - DMA_EV_ERR: address error event
551:                      *                              - DMA_EV_ABORT: transfer abort event
552:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
553:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
554:                      *                              - DMA_EV_DST_HALF: destination half event
555:                      *                              - DMA_EV_DST_FULL: destination full event
556:                      *                              - DMA_EV_SRC_HALF: source half event
557:                      *                              - DMA_EV_SRC_FULL: source full event
558:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
559:                      *
560:                      * Output:          None
561:                      *
562:                      * Side Effects:    None
563:                      *
564:                      * Overview:        The function clears the event flags for the selected DMA channel.
565:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
566:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
567:                      *
568:                      * Note:            None.
569:                      *
570:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
571:                      ********************************************************************/
572:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
573:                 
574:                     /*********************************************************************
575:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
576:                      *
577:                      * PreCondition:    chn - valid DMA channel
578:                      *
579:                      * Input:           chn     - DMA channel number
580:                      *
581:                      * Output:          event flags with the following significance:
582:                      *                      - DMA_EV_ERR: address error event
583:                      *                      - DMA_EV_ABORT: transfer abort event
584:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
585:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
586:                      *                      - DMA_EV_DST_HALF: destination half event
587:                      *                      - DMA_EV_DST_FULL: destination full event
588:                      *                      - DMA_EV_SRC_HALF: source half event
589:                      *                      - DMA_EV_SRC_FULL: source full event
590:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
591:                      *
592:                      * Side Effects:    None
593:                      *
594:                      * Overview:        The function returns the event flags for the selected DMA channel.
595:                      *
596:                      * Note:            None.
597:                      *
598:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
599:                      ********************************************************************/
600:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
601:                 
602:                 
603:                     // high level helpers for fast strcpy/memcpy transfers
604:                 
605:                     /*********************************************************************
606:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
607:                      *
608:                      * PreCondition:    chn     - a valid DMA channel
609:                      *                  s1, s2  - valid memory pointers
610:                      *                  n>0, n<=DmaGetMaxTxferSize()
611:                      *
612:                      * Input:           s1      - destination pointer
613:                      *                  s2      - source pointer
614:                      *                  n       - number of bytes to transfer
615:                      *                  chn     - the DMA channel to perform the transfer
616:                      *                  chPri   - the desired channel priority
617:                      *
618:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
619:                      *                  an DmaTxferRes error code  otherwise
620:                      *
621:                      * Side Effects:    None
622:                      *
623:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
624:                      *          Then it copies one block of memory from source to destination.
625:                      *
626:                      *
627:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
628:                      *                    This way, the transfer will occur correctly together with checksum calculation.
629:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
630:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
631:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
632:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
633:                      *
634:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
635:                      ********************************************************************/
636:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
637:                 
638:                     /*********************************************************************
639:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
640:                      *
641:                      * PreCondition:    chn     - a valid DMA channel
642:                      *                  s1, s2  - valid memory pointers
643:                      *
644:                      * Input:           s1      - destination pointer
645:                      *                  s2      - source pointer
646:                      *                  chn     - the DMA channel to perform the transfer
647:                      *                  chPri   - the desired channel priority
648:                      *
649:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
650:                      *                  an DmaTxferRes error code  otherwise
651:                      *
652:                      * Side Effects:    None
653:                      *
654:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
655:                      *          Then it copies one zero terminated string from source to destination.
656:                      *
657:                      *
658:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
659:                      *                    This way, the transfer will occur correctly together with checksum calculation.
660:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
661:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
662:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
663:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
664:                      *
665:                      *
666:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
667:                      *********************************************************************/
668:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
669:                 
670:                     /*********************************************************************
671:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
672:                      *
673:                      * PreCondition:    chn     - a valid DMA channel
674:                      *              - s1, s2    - valid memory pointers
675:                      *                              - 0 < n <= DmaGetMaxTxferSize()
676:                      *
677:                      * Input:           s1      - destination pointer
678:                      *                  s2      - source pointer
679:                      *                  n   - max number of bytes to transfer
680:                      *                  chn     - the DMA channel to perform the transfer
681:                      *                  chPri   - the desired channel priority
682:                      *
683:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
684:                      *                  an DmaTxferRes error code  otherwise
685:                      *
686:                      * Side Effects:    None
687:                      *
688:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
689:                      *          Then it copies one zero terminated string from source to destination.
690:                      *          It copies no more than n characters from s2.
691:                      *
692:                      *
693:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
694:                      *                    This way, the transfer will occur correctly together with checksum calculation.
695:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
696:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
697:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
698:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
699:                      *
700:                      *
701:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
702:                      ********************************************************************/
703:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
704:                 
705:                     /*********************************************************************
706:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
707:                      *
708:                      * PreCondition:    chn    - a valid DMA channel
709:                      *                  d, s   - valid memory pointer
710:                      *                  n>0, n<=DmaGetMaxTxferSize()
711:                      *
712:                      * Input:           d     - address where to deposit the result
713:                      *                  s     - source buffer pointer
714:                      *                  n     - number of bytes in the pointer
715:                      *                  chn   - the DMA channel to use
716:                      *                  chPri - the desired channel priority
717:                      *
718:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
719:                      *                  an DmaTxferRes error code  otherwise
720:                      *
721:                      * Side Effects:    None
722:                      *
723:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
724:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
725:                      *
726:                      *
727:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
728:                      *                  - No transfer is done, just the CRC is calculated.
729:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
730:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
731:                      *                  - The checksum type is switched to CRC.
732:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
733:                      *
734:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
735:                      ********************************************************************/
736:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
737:                 
738:                     /*********************************************************************
739:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
740:                      *
741:                      * PreCondition:    chn    - a valid DMA channel
742:                      *                  d, s   - valid memory pointer
743:                      *                  n>0, n<=DmaGetMaxTxferSize()
744:                      *
745:                      * Input:           d     - address where to deposit the result
746:                      *                  s     - source buffer pointer
747:                      *                  n     - number of bytes in the pointer
748:                      *                  chn   - the DMA channel to use
749:                      *                  chPri - the desired channel priority
750:                      *
751:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
752:                      *                  an DmaTxferRes error code  otherwise
753:                      *
754:                      * Side Effects:    None
755:                      *
756:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
757:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
758:                      *
759:                      *
760:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
761:                      *                  - No transfer is done, just the checksum is calculated.
762:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
763:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
764:                      *                  - The checksum type is switched to IP checksum.
765:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
766:                      *
767:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
768:                      ********************************************************************/
769:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
770:                 
771:                     // High level Special Function Module (SFM) functions
772:                 
773:                     /*********************************************************************
774:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
775:                      *
776:                      * PreCondition:    cType, bitO, rMode - valid values
777:                      *
778:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
779:                      *                  bitO  - the bit order to be used MSb or LSb first
780:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
781:                      *
782:                      * Output:          None
783:                      *
784:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
785:                      *
786:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
787:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
788:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
789:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
790:                      *                      All these values affect the way the checksum is calculated.
791:                      *
792:                      * Note:            None
793:                      *
794:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
795:                      ********************************************************************/
796:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
797:                     {
798:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
799:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
800:                     }
801:                 
802:                     /*********************************************************************
803:                      * Function:        void DmaSfmTxferReorder(int enable)
804:                      *
805:                      * PreCondition:    None
806:                      *
807:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
808:                      *
809:                      * Output:          None
810:                      *
811:                      * Side Effects:    None
812:                      *
813:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
814:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
815:                      *                  Otherwise the data is written to the destination un-modified.
816:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
817:                      *
818:                      *
819:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
820:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
821:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
822:                      *                    Un-aligned transfers are not supported (undefined behavior)!
823:                      *
824:                      * Example:         DmaSfmTxferReorder();
825:                      ********************************************************************/
826:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
827:                     {
828:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
829:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
830:                     }
831:                 
832:                 
833:                      /*********************************************************************
834:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
835:                      *
836:                      * PreCondition:    pLen   - valid polynomial length within 1-32
837:                      *
838:                      * Input:           polynomial  - the layout of the CRC generator
839:                      *                  pLen        - the length of the CRC generator polynomial
840:                      *                  seed        - the initial seed of the CRC generator
841:                      *
842:                      * Output:          None
843:                      *
844:                      * Side Effects:    None
845:                      *
846:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
847:                      *                  - the length of the CRC generator polynomial, pLen;
848:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
849:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
850:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
851:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
852:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
853:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
854:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
855:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
856:                      *
857:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
858:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
859:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
860:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
861:                      *                    the CrcResult() function.
862:                      *                  - The CRC module should be configured before enabled.
863:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
864:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
865:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
866:                      *
867:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
868:                      ********************************************************************/
869:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
870:                     {
871:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
872:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
873:                         DCRCDATA=seed;
874:                         DCRCXOR=polynomial;
875:                     }
876:                 
877:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
878:                 
879:                 
880:                     /*********************************************************************
881:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
882:                      *
883:                      * PreCondition:    chn    - valid DMA channel
884:                      *
885:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
886:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
887:                      *                                but it's written to the destination address when the block transfer is complete.
888:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
889:                      *                                The checksum will be available using the DmaSfmChecksum function.
890:                      *
891:                      * Output:          None
892:                      *
893:                      * Side Effects:    None
894:                      *
895:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
896:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
897:                      *                  is complete, the checksum result is available in the checksum data register.
898:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
899:                 
900:                      *
901:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
902:                      *
903:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
904:                      ********************************************************************/
905:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
906:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
907:                 
908:                     /*********************************************************************
909:                      * Function:        unsigned int DmaSfmChecksum(void)
910:                      *
911:                      * PreCondition:    None
912:                      *
913:                      * Input:           None
914:                      *
915:                      * Output:          the current value of the checksum generator.
916:                      *
917:                      * Side Effects:    None
918:                      *
919:                      * Overview:        The function returns the calculated checksum value.
920:                      *
921:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
922:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
923:                      *
924:                      * Example:         unsigned int myChk=DmaSfmChecksum();
925:                      ********************************************************************/
926:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
927:                     {
928:                         return DCRCDATA;
929:                     }
930:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
931:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
932:                 
933:                 
934:                     /*********************************************************************
935:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
936:                      *
937:                      * PreCondition:    None
938:                      *
939:                      * Input:           seed    - the initial seed of the checksum generator
940:                      *
941:                      * Output:          None
942:                      *
943:                      * Side Effects:    None
944:                      *
945:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
946:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
947:                      *
948:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
949:                      *
950:                      * Example:         DmaSfmSetSeed(0xffffffff);
951:                      ********************************************************************/
952:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
953:                     {
954:                         DCRCDATA=seed;
955:                     }
956:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
957:                 
958:                 
959:                 /*********************  end of high level functions ****************************************/
960:                 
961:                     // low level definitions for the API functions
962:                 
963:                 
964:                     typedef struct
965:                     {
966:                         union
967:                         {
968:                             struct
969:                             {
970:                                 unsigned int chn:   3;      // last active DMA channel
971:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
972:                             };
973:                             unsigned int    w;                      // word access
974:                         }lastAccess;
975:                         void*   lastAddress;        // most recent DMA address
976:                     }DmaStatus;         // DMA controller status
977:                 
978:                     typedef enum
979:                     {
980:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
981:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
982:                         //
983:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
984:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
985:                 
986:                 
987:                 
988:                 
989:                     typedef enum
990:                     {
991:                         DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
992:                         DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
993:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
994:                         // the start and abort IRQ signals
995:                         DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
996:                 
997:                 
998:                         // compiler use only field
999:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1000:                    }DmaEvCtrlFlags;    // DMA channel event control fields accessibile as flags
1001:                    // also part of DmaEvCtrlFlags:
1002:                    #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1003:                    #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1004:                
1005:                    // DMA channel event control as a structure:
1006:                    #define DmaEvCtrl   __DCH0ECONbits_t
1007:                
1008:                
1009:                
1010:                
1011:                    typedef enum
1012:                    {
1013:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1014:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1015:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1016:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1017:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1018:                        // use the DMA_CTL_PRI() below for selecting the DMA
1019:                        // channel priority
1020:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1021:                    // also part of DmaChnCtrlFlags:
1022:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1023:                
1024:                    // DMA channel control as a structure:
1025:                    #define DmaChnCtrl      __DCH0CONbits_t
1026:                
1027:                    typedef struct
1028:                    {
1029:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1030:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1031:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1032:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1033:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1034:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1035:                
1036:                
1037:                    /********************** low level DMA channel functions *******************************/
1038:                
1039:                
1040:                
1041:                    // Global DMA controller functions
1042:                
1043:                    /*********************************************************************
1044:                     * Function:        void DmaEnable(int enable)
1045:                     *
1046:                     * PreCondition:    None
1047:                     *
1048:                     * Input:           enable - boolean to enable/disable the DMA controller
1049:                     *
1050:                     * Output:          None
1051:                     *
1052:                     * Side Effects:    None
1053:                     *
1054:                     * Overview:       The function enables/disables the DMA controller.
1055:                     *
1056:                     * Note:           None.
1057:                     *
1058:                     * Example:        DmaEnable(1);
1059:                     ********************************************************************/
1060:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1061:                    {
1062:                        if(enable)
1063:                        {
1064:                            DMACONSET=_DMACON_ON_MASK;
1065:                        }
1066:                        else
1067:                        {
1068:                            DMACONCLR=_DMACON_ON_MASK;
1069:                            while(DMACONbits.ON);       // wait to take effect
1070:                        }
1071:                    }
1072:                
1073:                    /*********************************************************************
1074:                     * Function:        void DmaReset(void)
1075:                     *
1076:                     * PreCondition:    None
1077:                     *
1078:                     * Input:       None
1079:                     *
1080:                     * Output:          None
1081:                     *
1082:                     * Side Effects:    None
1083:                     *
1084:                     * Overview:        The function resets the DMA controller.
1085:                     *
1086:                     * Note:            None.
1087:                     *
1088:                     * Example:        DmaReset();
1089:                     ********************************************************************/
1090:                    #define            DmaReset()   DmaEnable(0)
1091:                
1092:                
1093:                    /*********************************************************************
1094:                     * Function:        int DmaSuspend(void)
1095:                     *
1096:                     * PreCondition:    None
1097:                     *
1098:                     * Input:       None
1099:                     *
1100:                     * Output:          true if the DMA was previously suspended, false otherwise
1101:                     *
1102:                     *
1103:                     * Side Effects:    None
1104:                     *
1105:                     * Overview:        The function suspends the DMA controller.
1106:                     *
1107:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1108:                     *                  I.e. the function has to wait for the suspension to take place!
1109:                     *
1110:                     * Example:         int susp=DmaSuspend();
1111:                     ********************************************************************/
1112:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1113:                    {
1114:                        int suspSt;
1115:                        if(!(suspSt=DMACONbits.SUSPEND))
9D001714  3C02BF88   LUI V0, -16504
9D001718  8C423000   LW V0, 12288(V0)
9D00171C  7C420300   EXT V0, V0, 12, 1
9D001720  304200FF   ANDI V0, V0, 255
9D001724  AFC2002C   SW V0, 44(S8)
9D001728  8FC2002C   LW V0, 44(S8)
9D00172C  14400009   BNE V0, ZERO, 0x9D001754
9D001730  00000000   NOP
9D0017E8  3C02BF88   LUI V0, -16504
9D0017EC  8C423000   LW V0, 12288(V0)
9D0017F0  7C420300   EXT V0, V0, 12, 1
9D0017F4  304200FF   ANDI V0, V0, 255
9D0017F8  AFC20038   SW V0, 56(S8)
9D0017FC  8FC20038   LW V0, 56(S8)
9D001800  1440000E   BNE V0, ZERO, 0x9D00183C
9D001804  00000000   NOP
1116:                        {
1117:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D001734  3C02BF88   LUI V0, -16504
9D001738  24031000   ADDIU V1, ZERO, 4096
9D00173C  AC433008   SW V1, 12296(V0)
9D001808  3C02BF88   LUI V0, -16504
9D00180C  24031000   ADDIU V1, ZERO, 4096
9D001810  AC433008   SW V1, 12296(V0)
1118:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D001740  3C02BF88   LUI V0, -16504
9D001744  8C423000   LW V0, 12288(V0)
9D001748  30420800   ANDI V0, V0, 2048
9D00174C  1440FFFC   BNE V0, ZERO, 0x9D001740
9D001750  00000000   NOP
9D001814  3C02BF88   LUI V0, -16504
9D001818  8C423000   LW V0, 12288(V0)
9D00181C  30420800   ANDI V0, V0, 2048
9D001820  1440FFFC   BNE V0, ZERO, 0x9D001814
9D001824  00000000   NOP
9D001828  0B40060F   J 0x9D00183C
9D00182C  00000000   NOP
1119:                        }
1120:                        return suspSt;
9D001754  8FC2002C   LW V0, 44(S8)
1121:                    }
1122:                
1123:                
1124:                
1125:                    /*********************************************************************
1126:                     * Function:        void DmaResume(int susp)
1127:                     *
1128:                     * PreCondition:    None
1129:                     *
1130:                     * Input:       the desired DMA suspended state.
1131:                     *
1132:                     * Output:          None
1133:                     *
1134:                     * Side Effects:    None
1135:                     *
1136:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1137:                     *
1138:                     * Note:            None.
1139:                     *
1140:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1141:                     ********************************************************************/
1142:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1143:                    {
1144:                        if(susp)
9D0017DC  8FC20034   LW V0, 52(S8)
9D0017E0  10400013   BEQ V0, ZERO, 0x9D001830
9D0017E4  00000000   NOP
1145:                        {
1146:                            DmaSuspend();
1147:                        }
1148:                        else
1149:                        {
1150:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D001830  3C02BF88   LUI V0, -16504
9D001834  24031000   ADDIU V1, ZERO, 4096
9D001838  AC433004   SW V1, 12292(V0)
1151:                        }
1152:                    }
1153:                
1154:                    /*********************************************************************
1155:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1156:                     *
1157:                     * PreCondition:    pStat   - valid pointer
1158:                     *
1159:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1160:                     *                          status, carrying the following info:
1161:                     *                              - chn:  the last active DMA channel
1162:                     *                              - rdOp: the last DMA operation, read/write
1163:                     *                              - lastAddress: the most recent DMA address
1164:                     *
1165:                     * Output:          None
1166:                     *
1167:                     * Side Effects:    None
1168:                     *
1169:                     * Overview:        The function updates the info for the current DMA controller status.
1170:                     *                  It updates the last DMA: operation, channel used and address.
1171:                     *
1172:                     * Note:            None.
1173:                     *
1174:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1175:                     ********************************************************************/
1176:                     void           DmaGetStatus(DmaStatus* pStat);
1177:                
1178:                    /*********************************************************************
1179:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1180:                     *
1181:                     * PreCondition:    None
1182:                     *
1183:                     * Input:           gFlags - flags to be set, having the following fields:
1184:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1185:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1186:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1187:                     *
1188:                     * Output:          None
1189:                     *
1190:                     * Side Effects:    None
1191:                     *
1192:                     * Overview:        The function affects the global behavior of the DMA controller.
1193:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1194:                     *                  enabled, the other flags won't be touched.
1195:                     *
1196:                     * Note:            None.
1197:                     *
1198:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1199:                     ********************************************************************/
1200:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1201:                    {
1202:                        DMACONSET=gFlags;
1203:                    }
1204:                
1205:                    /*********************************************************************
1206:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1207:                     *
1208:                     * PreCondition:    None
1209:                     *
1210:                     * Input:           gFlags - flags to be cleared, having the following fields:
1211:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1212:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1213:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1214:                     *
1215:                     * Output:          None
1216:                     *
1217:                     * Side Effects:    None
1218:                     *
1219:                     * Overview:        The function affects the global behavior of the DMA controller.
1220:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1221:                     *                  cleared, the other flags won't be touched.
1222:                     *
1223:                     * Note:            None.
1224:                     *
1225:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1226:                     ********************************************************************/
1227:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1228:                    {
1229:                        DMACONCLR=gFlags;
1230:                    }
1231:                
1232:                
1233:                    /*********************************************************************
1234:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1235:                     *
1236:                     * PreCondition:    None
1237:                     *
1238:                     * Input:           gFlags - flags to be set, having the following fields:
1239:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1240:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1241:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1242:                     *
1243:                     * Output:          None
1244:                     *
1245:                     * Side Effects:    None
1246:                     *
1247:                     * Overview:        The function affects the global behavior of the DMA controller.
1248:                     *                  It forces the flags to have the specified gFlags value.
1249:                     *
1250:                     * Note:            None.
1251:                     *
1252:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1253:                     ********************************************************************/
1254:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1255:                    {
1256:                        DMACON=gFlags;
1257:                    }
1258:                
1259:                    /*********************************************************************
1260:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1261:                     *
1262:                     * PreCondition:    None
1263:                     *
1264:                     * Input:           None
1265:                     *
1266:                     * Output:          The current DMA controller flags settings.
1267:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1268:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1269:                     *
1270:                     * Side Effects:    None
1271:                     *
1272:                     * Overview:        The function returns the global flags of the DMA controller.
1273:                     *
1274:                     * Note:            None.
1275:                     *
1276:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1277:                     ********************************************************************/
1278:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1279:                    {
1280:                        return (DmaGlblFlags)DMACON;
1281:                    }
1282:                
1283:                
1284:                    /*********************************************************************
1285:                     * Function:        int DmaGetMaxTxferSize(void)
1286:                     *
1287:                     * PreCondition:    None
1288:                     *
1289:                     * Input:           None
1290:                     *
1291:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1292:                     *
1293:                     * Side Effects:    None
1294:                     *
1295:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1296:                     *
1297:                     * Note:            Revision dependant.
1298:                     *
1299:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1300:                     ********************************************************************/
1301:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1302:                    {
1303:                        return 65536;
1304:                    }
1305:                
1306:                    // Direct Channel control functions
1307:                
1308:                    typedef enum
1309:                    {
1310:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1311:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1312:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1313:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1314:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1315:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1316:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1317:                    }DmaConfigFlags;    // flags for the channel configuration
1318:                
1319:                
1320:                
1321:                    /*********************************************************************
1322:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1323:                     *
1324:                     * PreCondition:    chPri  - valid channel priority, 0-3
1325:                     *
1326:                     * Input:           chn    - channel to be configured in the DMA controller
1327:                     *                  chPri  - the priority given to the channel, 0-3
1328:                     *                  cFlags - orred flags specifying the configuration:
1329:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1330:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1331:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1332:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1333:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1334:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1335:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1336:                     *
1337:                     *
1338:                     *
1339:                     * Output:          None
1340:                     *
1341:                     * Side Effects:    None
1342:                     *
1343:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1344:                     *
1345:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1346:                     *                  The channel is just configured.
1347:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1348:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1349:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1350:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1351:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1352:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1353:                     *
1354:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1355:                     ********************************************************************/
1356:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1357:                
1358:                
1359:                    /*********************************************************************
1360:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1361:                     *
1362:                     * PreCondition:    chn - valid DMA channel
1363:                     *
1364:                     * Input:           chn     - DMA channel number
1365:                     *
1366:                     * Output:          Current channel source pointer.
1367:                     *
1368:                     * Side Effects:    None
1369:                     *
1370:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1371:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1372:                     *
1373:                     * Note:            None
1374:                     *
1375:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1376:                     ********************************************************************/
1377:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1378:                
1379:                    /*********************************************************************
1380:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1381:                     *
1382:                     * PreCondition:    chn - valid DMA channel
1383:                     *
1384:                     * Input:           chn     - DMA channel number
1385:                     *
1386:                     * Output:          Current channel destination pointer.
1387:                     *
1388:                     * Side Effects:    None
1389:                     *
1390:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1391:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1392:                     *
1393:                     * Note:            None
1394:                     *
1395:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1396:                     ********************************************************************/
1397:                     int            DmaChnGetDstPnt(DmaChannel chn);
1398:                
1399:                    /*********************************************************************
1400:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1401:                     *
1402:                     * PreCondition:    chn - valid DMA channel
1403:                     *
1404:                     * Input:           chn     - DMA channel number
1405:                     *
1406:                     * Output:          Current channel transfer pointer.
1407:                     *
1408:                     * Side Effects:    None
1409:                     *
1410:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1411:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1412:                     *
1413:                     * Note:            None
1414:                     *
1415:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1416:                     ********************************************************************/
1417:                     int            DmaChnGetCellPnt(DmaChannel chn);
1418:                
1419:                
1420:                
1421:                    /*********************************************************************
1422:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1423:                     *
1424:                     * PreCondition:    chn - valid DMA channel
1425:                     *
1426:                     * Input:           chn         - DMA channel number
1427:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1428:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1429:                     *                                      - SIRQEN: enable/disable the start IRQ action
1430:                     *                                      - PATEN: enable/disable the pattern match and abort
1431:                     *                                  or any of the DmaEvCtrlFlags:
1432:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1433:                     *
1434:                     *
1435:                     * Output:          None
1436:                     *
1437:                     * Side Effects:    None
1438:                     *
1439:                     * Overview:        The function sets the events that start and abort the transfer
1440:                     *                  for the selected DMA channel.
1441:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1442:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1443:                     *
1444:                     * Note:            None.
1445:                     *
1446:                     * Example:         either:
1447:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1448:                     *                  or:
1449:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1450:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1451:                     *
1452:                     ********************************************************************/
1453:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1454:                
1455:                
1456:                    /*********************************************************************
1457:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1458:                     *
1459:                     * PreCondition:    chn - valid DMA channel
1460:                     *
1461:                     * Input:           chn         - DMA channel number
1462:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1463:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1464:                     *                                      - SIRQEN: enable/disable the start IRQ action
1465:                     *                                      - PATEN: enable/disable the pattern match and abort
1466:                     *                                  or any of the DmaEvCtrlFlags:
1467:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1468:                     *
1469:                     *
1470:                     * Output:          None
1471:                     *
1472:                     * Side Effects:    None
1473:                     *
1474:                     * Overview:        The function clears the events that start and abort the transfer
1475:                     *                  for the selected DMA channel.
1476:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1477:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1478:                     *
1479:                     * Note:            None.
1480:                     *
1481:                     * Example:         either:
1482:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1483:                     *                  or:
1484:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1485:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1486:                     *
1487:                     ********************************************************************/
1488:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1489:                
1490:                
1491:                
1492:                    /*********************************************************************
1493:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1494:                     *
1495:                     * PreCondition:    chn - valid DMA channel
1496:                     *
1497:                     * Input:           chn         - DMA channel number
1498:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1499:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1500:                     *                                      - SIRQEN: enable/disable the start IRQ action
1501:                     *                                      - PATEN: enable/disable the pattern match and abort
1502:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1503:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1504:                     *                                  or any of the DmaEvCtrlFlags:
1505:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1506:                     *
1507:                     *
1508:                     * Output:          None
1509:                     *
1510:                     * Side Effects:    None
1511:                     *
1512:                     * Overview:        The function writes the events that start and abort the transfer
1513:                     *                  for the selected DMA channel.
1514:                     *
1515:                     * Note:            None.
1516:                     *
1517:                     * Example:         either:
1518:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1519:                     *                  or:
1520:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1521:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1522:                     *
1523:                     ********************************************************************/
1524:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1525:                
1526:                
1527:                
1528:                    /*********************************************************************
1529:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1530:                     *
1531:                     * PreCondition:    chn - valid DMA channel
1532:                     *
1533:                     * Input:           chn         - DMA channel number
1534:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1535:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1536:                     *                                      - SIRQEN: enable/disable the start IRQ action
1537:                     *                                      - PATEN: enable/disable the pattern match and abort
1538:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1539:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1540:                     *                                  or any of the DmaEvCtrlFlags:
1541:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1542:                     *
1543:                     *
1544:                     * Output:          None
1545:                     *
1546:                     * Side Effects:    None
1547:                     *
1548:                     * Overview:        The function sets the events that start and abort the transfer
1549:                     *                  for the selected DMA channel.
1550:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1551:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1552:                     *
1553:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1554:                     *
1555:                     * Example:         either:
1556:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1557:                     *                  or:
1558:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1559:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1560:                     *
1561:                     ********************************************************************/
1562:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1563:                
1564:                
1565:                    /*********************************************************************
1566:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1567:                     *
1568:                     * PreCondition:    chn - valid DMA channel
1569:                     *
1570:                     * Input:           chn     - DMA channel number
1571:                     *
1572:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1573:                     *                          - AIRQEN: enable/disable the abort IRQ action
1574:                     *                          - SIRQEN: enable/disable the start IRQ action
1575:                     *                          - PATEN: enable/disable the pattern match and abort
1576:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1577:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1578:                     *                      or any of the DmaEvCtrlFlags:
1579:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1580:                     *
1581:                     *
1582:                     * Side Effects:    None
1583:                     *
1584:                     * Overview:        The function retrieves the events that start and abort the transfer
1585:                     *                  for the selected DMA channel.
1586:                     *
1587:                     * Note:            None.
1588:                     *
1589:                     * Example:         either:
1590:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1591:                     *                  or:
1592:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1593:                     *
1594:                     ********************************************************************/
1595:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1596:                
1597:                
1598:                    /*********************************************************************
1599:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1600:                     *
1601:                     * PreCondition:    chn - valid DMA channel
1602:                     *
1603:                     * Input:           chn         - DMA channel number
1604:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1605:                     *                                      - autoEn: enable/disable the automatic mode
1606:                     *                                      - chainEn: enable/disable channel chaining
1607:                     *                                      - detectEn: enable/disable events detection when channel disabled
1608:                     *                                      - chEn: enable/disable channel functionality
1609:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1610:                     *                                  or any of the DmaChnCtrlFlags flags:
1611:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1612:                     *
1613:                     * Output:          None
1614:                     *
1615:                     * Side Effects:    None
1616:                     *
1617:                     * Overview:        The function sets the selected DMA channel control flags:
1618:                     *                  the chaining or auto mode, and events detection.
1619:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1620:                     *                  set for the selected channel, the other channel control flags won't be touched.
1621:                     *
1622:                     * Note:            None.
1623:                     *
1624:                     * Example:         either:
1625:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1626:                     *                  or:
1627:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1628:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1629:                     *
1630:                     ********************************************************************/
1631:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1632:                
1633:                    /*********************************************************************
1634:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1635:                     *
1636:                     * PreCondition:    chn - valid DMA channel
1637:                     *
1638:                     * Input:           chn         - DMA channel number
1639:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1640:                     *                                      - autoEn: enable/disable the automatic mode
1641:                     *                                      - chainEn: enable/disable channel chaining
1642:                     *                                      - detectEn: enable/disable events detection when channel disabled
1643:                     *                                      - chEn: enable/disable channel functionality
1644:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1645:                     *                                  or any of the DmaChnCtrlFlags flags:
1646:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1647:                     *
1648:                     * Output:          None
1649:                     *
1650:                     * Side Effects:    None
1651:                     *
1652:                     * Overview:        The function clears the selected DMA channel control flags:
1653:                     *                  the chaining or auto mode and events detection.
1654:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1655:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1656:                     *
1657:                     * Note:            None.
1658:                     *
1659:                     * Example:         either:
1660:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1661:                     *                  or:
1662:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1663:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1664:                     *
1665:                     ********************************************************************/
1666:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1667:                
1668:                    /*********************************************************************
1669:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1670:                     *
1671:                     * PreCondition:    chn - valid DMA channel
1672:                     *
1673:                     * Input:           chn         - DMA channel number
1674:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1675:                     *                                      - chPri: channel priority 0-3
1676:                     *                                      - autoEn: enable/disable the automatic mode
1677:                     *                                      - chainEn: enable/disable channel chaining
1678:                     *                                      - detectEn: enable/disable events detection when channel disabled
1679:                     *                                      - chEn: enable/disable channel functionality
1680:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1681:                     *                                  or any of the DmaChnCtrlFlags flags:
1682:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1683:                     *
1684:                     * Output:          None
1685:                     *
1686:                     * Side Effects:    None
1687:                     *
1688:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1689:                     *                  the channel priority, chaining mode or auto and events detection.
1690:                     *
1691:                     * Note:            None.
1692:                     *
1693:                     * Example:         either:
1694:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1695:                     *                  or:
1696:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1697:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1698:                     *
1699:                     ********************************************************************/
1700:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1701:                
1702:                    /*********************************************************************
1703:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1704:                     *
1705:                     * PreCondition:    chn - valid DMA channel
1706:                     *
1707:                     * Input:       chn     - DMA channel number
1708:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1709:                     *                      - chPri: channel priority 0-3
1710:                     *                      - autoEn: enable/disable the automatic mode
1711:                     *                      - chainEn: enable/disable channel chaining
1712:                     *                      - detectEn: enable/disable events detection when channel disabled
1713:                     *                      - chEn: enable/disable channel functionality
1714:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1715:                     *                  or any of the DmaChnCtrlFlags flags:
1716:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1717:                     *
1718:                     * Output:          None
1719:                     *
1720:                     * Side Effects:    None
1721:                     *
1722:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1723:                     *                  the channel priority, chaining mode or auto and events detection.
1724:                     *
1725:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1726:                     *
1727:                     * Example:         either:
1728:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1729:                     *                  or:
1730:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1731:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1732:                     *
1733:                     ********************************************************************/
1734:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1735:                
1736:                    /*********************************************************************
1737:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1738:                     *
1739:                     * PreCondition:    chn - valid DMA channel
1740:                     *
1741:                     * Input:           chn         - DMA channel number
1742:                     *
1743:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1744:                     *                          - chPri: channel priority 0-3
1745:                     *                          - autoEn: enable/disable the automatic mode
1746:                     *                          - chainEn: enable/disable channel chaining
1747:                     *                          - detectEn: enable/disable events detection when channel disabled
1748:                     *                          - chEn: enable/disable channel functionality
1749:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1750:                     *                      or any of the DmaChnCtrlFlags flags:
1751:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1752:                     *
1753:                     * Side Effects:    None
1754:                     *
1755:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1756:                     *                  including the channel enable/disable status, the channel priority,
1757:                     *                  chaining mode, auto mode and events detection.
1758:                     *
1759:                     * Note:            None.
1760:                     *
1761:                     * Example:         either:
1762:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1763:                     *                  or:
1764:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1765:                     *
1766:                     ********************************************************************/
1767:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1768:                
1769:                
1770:                    /*********************************************************************
1771:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1772:                     *
1773:                     * PreCondition:    chn - valid DMA channel
1774:                     *
1775:                     * Input:           chn     - DMA channel number
1776:                     *
1777:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1778:                     *
1779:                     * Side Effects:    None
1780:                     *
1781:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1782:                     *
1783:                     * Note:            None.
1784:                     *
1785:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1786:                     *
1787:                     ********************************************************************/
1788:                     int            DmaChnGetEvDetect(DmaChannel chn);
1789:                
1790:                    /*********************************************************************
1791:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1792:                     *
1793:                     * PreCondition:    chn     - valid DMA channel
1794:                     *                  pTxCtrl - valid pointer
1795:                     *
1796:                     * Input:           chn         - DMA channel number
1797:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1798:                     *                              - vSrcAdd: source of the DMA transfer
1799:                     *                              - vDstAdd: destination of the DMA transfer
1800:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1801:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1802:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1803:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1804:                     *
1805:                     * Output:          None
1806:                     *
1807:                     * Side Effects:    None
1808:                     *
1809:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1810:                     *                  the source and the destination addresses.
1811:                     *                  It also retrieves the source and destination lengths
1812:                     *                  and the number of bytes transferred per event.
1813:                     *
1814:                     * Note:            None
1815:                     *
1816:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1817:                     ********************************************************************/
1818:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1819:                
1820:                    // Low level checksum functions
1821:                
1822:                    /*********************************************************************
1823:                     * Function:        void DmaSfmEnable(int enable)
1824:                     *
1825:                     * PreCondition:    None
1826:                     *
1827:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1828:                     *
1829:                     * Output:          None
1830:                     *
1831:                     * Side Effects:    None
1832:                     *
1833:                     * Overview:        The function enables/diables the checksum module functionality.
1834:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1835:                     *
1836:                     * Note:            The SFM module should be properly configured before enabled.
1837:                     *
1838:                     * Example:         DmaSfmEnable(1);
1839:                     ********************************************************************/
1840:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1841:                    {
1842:                        if(enable)
1843:                        {
1844:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1845:                        }
1846:                        else
1847:                        {
1848:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1849:                        }
1850:                    }
1851:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1852:                
1853:                
1854:                    /*********************************************************************
1855:                     * Function:        int DmaSfmGetEnable(void)
1856:                     *
1857:                     * PreCondition:    None
1858:                     *
1859:                     * Input:           None
1860:                     *
1861:                     * Output:          TRUE, if the SFM module is enabled
1862:                     *          FALSE otherwise
1863:                     *
1864:                     * Side Effects:    None
1865:                     *
1866:                     * Overview:        The function returns the SFM module enabling status.
1867:                     *
1868:                     * Note:            None
1869:                     *
1870:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1871:                     ********************************************************************/
1872:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1873:                    {
1874:                        return DCRCCONbits.CRCEN!=0;
1875:                    }
1876:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1877:                
1878:                
1879:                    /*********************************************************************
1880:                     * Function:        void DmaSfmAppendEnable(int enable)
1881:                     *
1882:                     * PreCondition:    None
1883:                     *
1884:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1885:                     *
1886:                     * Output:          None
1887:                     *
1888:                     * Side Effects:    None
1889:                     *
1890:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1891:                     *                  the source data but does not write it to the destination address. The data it's just passed
1892:                     *                  to the checksum generator for CRC/IP checksum calculation.
1893:                     *                  When the block transfer is completed, the checksum result is written to the
1894:                     *                  DMA channel destination address.
1895:                     *
1896:                     * Note:            The SFM module should be properly configured before enabled.
1897:                     *
1898:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1899:                     ********************************************************************/
1900:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1901:                    {
1902:                        if(enable)
1903:                        {
1904:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1905:                        }
1906:                        else
1907:                        {
1908:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1909:                        }
1910:                    }
1911:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1912:                
1913:                
1914:                    /*********************************************************************
1915:                     * Function:        int DmaSfmGetAppendMode(void)
1916:                     *
1917:                     * PreCondition:    None
1918:                     *
1919:                     * Input:           None
1920:                     *
1921:                     * Output:          TRUE, if the SFM append mode is enabled
1922:                     *                  FALSE otherwise
1923:                     *
1924:                     * Side Effects:    None
1925:                     *
1926:                     * Overview:        The function returns the SFM module enabling status.
1927:                     *
1928:                     * Note:            None
1929:                     *
1930:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1931:                     ********************************************************************/
1932:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1933:                    {
1934:                        return DCRCCONbits.CRCAPP!=0;
1935:                    }
1936:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1937:                
1938:                
1939:                    /*********************************************************************
1940:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1941:                     *
1942:                     * PreCondition:    chn     - valid DMA channel
1943:                     *
1944:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1945:                     *
1946:                     * Output:          None
1947:                     *
1948:                     * Side Effects:    None
1949:                     *
1950:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1951:                     *
1952:                     * Note:            None
1953:                     *
1954:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1955:                     ********************************************************************/
1956:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1957:                    {
1958:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1959:                        DCRCCONSET=chn;
1960:                    }
1961:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1962:                
1963:                
1964:                    /*********************************************************************
1965:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1966:                     *
1967:                     * PreCondition:    None
1968:                     *
1969:                     * Input:           None
1970:                     *
1971:                     * Output:          the DMA channel that is currently attached to the CRC module
1972:                     *
1973:                     * Side Effects:    None
1974:                     *
1975:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1976:                     *
1977:                     * Note:            None
1978:                     *
1979:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1980:                     ********************************************************************/
1981:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1982:                    {
1983:                        return (DmaChannel)DCRCCONbits.CRCCH;
1984:                    }
1985:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1986:                
1987:                    /*********************************************************************
1988:                     * Function:        void DmaCrcSetPLen(int pLen)
1989:                     *
1990:                     * PreCondition:    pLen - valid polynomial length within 1-32
1991:                     *
1992:                     * Input:           pLen    - the length of the CRC generator polynomial
1993:                     *
1994:                     * Output:          None
1995:                     *
1996:                     * Side Effects:    None
1997:                     *
1998:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
1999:                     *
2000:                     * Note:            None
2001:                     *
2002:                     * Example:         DmaCrcSetPLen(32);
2003:                     ********************************************************************/
2004:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2005:                    {
2006:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
2007:                        DCRCCONSET=(pLen)-1;
2008:                    }
2009:                
2010:                    /*********************************************************************
2011:                     * Function:        int DmaCrcGetPLen(void)
2012:                     *
2013:                     * PreCondition:    None
2014:                     *
2015:                     * Input:           None
2016:                     *
2017:                     * Output:          the length of the CRC generator polynomial
2018:                     *
2019:                     * Side Effects:    None
2020:                     *
2021:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2022:                     *                  It's always a number between 1 and 32.
2023:                     *
2024:                     * Note:            None
2025:                     *
2026:                     * Example:         int polyLen=DmaCrcGetPLen();
2027:                     ********************************************************************/
2028:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2029:                    {
2030:                        return  DCRCCONbits.PLEN+1;
2031:                    }
2032:                
2033:                    /*********************************************************************
2034:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2035:                     *
2036:                     * PreCondition:    None
2037:                     *
2038:                     * Input:           feedback - the layout of the CRC generator
2039:                     *
2040:                     * Output:          None
2041:                     *
2042:                     * Side Effects:    None
2043:                     *
2044:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2045:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2046:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2047:                     *
2048:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2049:                     *
2050:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2051:                     ********************************************************************/
2052:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2053:                    {
2054:                        DCRCXOR=feedback;
2055:                    }
2056:                
2057:                
2058:                    /*********************************************************************
2059:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2060:                     *
2061:                     * PreCondition:    None
2062:                     *
2063:                     * Input:           None
2064:                     *
2065:                     * Output:          the current layout of the CRC generator
2066:                     *
2067:                     * Side Effects:    None
2068:                     *
2069:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2070:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2071:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2072:                     *
2073:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2074:                     *
2075:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2076:                     ********************************************************************/
2077:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2078:                    {
2079:                        return DCRCXOR;
2080:                    }
2081:                
2082:                
2083:                
2084:                    // Channel test/debug and special functions
2085:                
2086:                    /*********************************************************************
2087:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2088:                     *
2089:                     * PreCondition:    chn - valid DMA channel
2090:                     *
2091:                     * Input:           chn     - DMA channel number
2092:                     *                  eFlags  - event flags with the following significance:
2093:                     *                              - DMA_EV_ERR: address error event
2094:                     *                              - DMA_EV_ABORT: transfer abort event
2095:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2096:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2097:                     *                              - DMA_EV_DST_HALF: destination half event
2098:                     *                              - DMA_EV_DST_FULL: destination full event
2099:                     *                              - DMA_EV_SRC_HALF: source half event
2100:                     *                              - DMA_EV_SRC_FULL: source full event
2101:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2102:                     *
2103:                     * Output:          None
2104:                     *
2105:                     * Side Effects:    None
2106:                     *
2107:                     * Overview:        The function sets the event flags for the selected DMA channel.
2108:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2109:                     *                  set for the selected channel, the other channel event flags won't be touched.
2110:                     *
2111:                     * Note:            This is intended as a channel test function.
2112:                     *
2113:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2114:                     ********************************************************************/
2115:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2116:                
2117:                    /*********************************************************************
2118:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2119:                     *
2120:                     * PreCondition:    chn - valid DMA channel
2121:                     *
2122:                     * Input:           chn     - DMA channel number
2123:                     *                  eFlags  - event flags with the following significance:
2124:                     *                              - DMA_EV_ERR: address error event
2125:                     *                              - DMA_EV_ABORT: transfer abort event
2126:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2127:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2128:                     *                              - DMA_EV_DST_HALF: destination half event
2129:                     *                              - DMA_EV_DST_FULL: destination full event
2130:                     *                              - DMA_EV_SRC_HALF: source half event
2131:                     *                              - DMA_EV_SRC_FULL: source full event
2132:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2133:                     *
2134:                     * Output:          None
2135:                     *
2136:                     * Side Effects:    None
2137:                     *
2138:                     * Overview:        The function writes the event flags for the selected DMA channel.
2139:                     *                  The channel event flags are forced to the eFlags value.
2140:                     *
2141:                     * Note:            This is intended as a channel test function.
2142:                     *
2143:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2144:                     ********************************************************************/
2145:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2146:                
2147:                
2148:                    /********************************************************************
2149:                     * Include legacy DMA functions
2150:                     * New projects should not use them!
2151:                     * Note that interrupt functions are no longer provided.
2152:                     * The functions in the int.h should be used instead.
2153:                     ********************************************************************/
2154:                    #ifndef _PLIB_DISABLE_LEGACY
2155:                        #include <peripheral/legacy/dma_legacy.h>
2156:                    #endif
2157:                
2158:                
2159:                #else
2160:                    #undef _DMA_CHANNELS        // no DMA channels
2161:                #endif  // _DMAC0
2162:                
2163:                #endif /*_DMA_1XX_2XX_H_*/
2164:                
2165:                
